import type { EncryptedMessage, WalletConfig, WalletExportImportConfig, WalletConfigRekey } from '../types';
import type { Buffer } from '../utils/buffer';
import type { Wallet, DidInfo, DidConfig, UnpackedMessageContext } from './Wallet';
import { AgentConfig } from '../agent/AgentConfig';
export declare class IndyWallet implements Wallet {
    private walletConfig?;
    private walletHandle?;
    private logger;
    private publicDidInfo;
    private indy;
    constructor(agentConfig: AgentConfig);
    get isProvisioned(): boolean;
    get isInitialized(): boolean;
    get publicDid(): DidInfo | undefined;
    get handle(): number;
    get masterSecretId(): string;
    private walletStorageConfig;
    private walletCredentials;
    /**
     * @throws {WalletDuplicateError} if the wallet already exists
     * @throws {WalletError} if another error occurs
     */
    create(walletConfig: WalletConfig): Promise<void>;
    /**
     * @throws {WalletDuplicateError} if the wallet already exists
     * @throws {WalletError} if another error occurs
     */
    createAndOpen(walletConfig: WalletConfig): Promise<void>;
    /**
     * @throws {WalletNotFoundError} if the wallet does not exist
     * @throws {WalletError} if another error occurs
     */
    open(walletConfig: WalletConfig): Promise<void>;
    /**
     * @throws {WalletNotFoundError} if the wallet does not exist
     * @throws {WalletError} if another error occurs
     */
    rotateKey(walletConfig: WalletConfigRekey): Promise<void>;
    /**
     * @throws {WalletNotFoundError} if the wallet does not exist
     * @throws {WalletError} if another error occurs
     */
    private _open;
    /**
     * @throws {WalletNotFoundError} if the wallet does not exist
     * @throws {WalletError} if another error occurs
     */
    delete(): Promise<void>;
    export(exportConfig: WalletExportImportConfig): Promise<void>;
    import(walletConfig: WalletConfig, importConfig: WalletExportImportConfig): Promise<void>;
    /**
     * @throws {WalletError} if the wallet is already closed or another error occurs
     */
    close(): Promise<void>;
    /**
     * Create master secret with specified id in currently opened wallet.
     *
     * If a master secret by this id already exists in the current wallet, the method
     * will return without doing anything.
     *
     * @throws {WalletError} if an error occurs
     */
    private createMasterSecret;
    initPublicDid(didConfig: DidConfig): Promise<void>;
    createDid(didConfig?: DidConfig): Promise<DidInfo>;
    pack(payload: Record<string, unknown>, recipientKeys: string[], senderVerkey?: string): Promise<EncryptedMessage>;
    unpack(messagePackage: EncryptedMessage): Promise<UnpackedMessageContext>;
    sign(data: Buffer, verkey: string): Promise<Buffer>;
    verify(signerVerkey: string, data: Buffer, signature: Buffer): Promise<boolean>;
    generateNonce(): Promise<string>;
}
