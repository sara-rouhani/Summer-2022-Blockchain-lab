"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.UpdateAssistant = void 0;
const error_1 = require("../../error");
const version_1 = require("../../utils/version");
const WalletError_1 = require("../../wallet/error/WalletError");
const StorageUpdateService_1 = require("./StorageUpdateService");
const StorageUpdateError_1 = require("./error/StorageUpdateError");
const updates_1 = require("./updates");
class UpdateAssistant {
    constructor(agent, updateConfig) {
        this.agent = agent;
        this.updateConfig = updateConfig;
        this.storageUpdateService = this.agent.dependencyManager.resolve(StorageUpdateService_1.StorageUpdateService);
    }
    async initialize() {
        if (this.agent.isInitialized) {
            throw new error_1.AriesFrameworkError("Can't initialize UpdateAssistant after agent is initialized");
        }
        // Initialize the wallet if not already done
        if (!this.agent.wallet.isInitialized && this.agent.config.walletConfig) {
            await this.agent.wallet.initialize(this.agent.config.walletConfig);
        }
        else if (!this.agent.wallet.isInitialized) {
            throw new WalletError_1.WalletError('Wallet config has not been set on the agent config. ' +
                'Make sure to initialize the wallet yourself before initializing the update assistant, ' +
                'or provide the required wallet configuration in the agent constructor');
        }
    }
    async isUpToDate() {
        return this.storageUpdateService.isUpToDate();
    }
    async getCurrentAgentStorageVersion() {
        return this.storageUpdateService.getCurrentStorageVersion();
    }
    static get frameworkStorageVersion() {
        return updates_1.CURRENT_FRAMEWORK_STORAGE_VERSION;
    }
    async getNeededUpdates() {
        const currentStorageVersion = version_1.parseVersionString(await this.storageUpdateService.getCurrentStorageVersion());
        // Filter updates. We don't want older updates we already applied
        // or aren't needed because the wallet was created after the update script was made
        const neededUpdates = updates_1.supportedUpdates.filter((update) => {
            const toVersion = version_1.parseVersionString(update.toVersion);
            // if an update toVersion is higher than currentStorageVersion we want to to include the update
            return version_1.isFirstVersionHigherThanSecond(toVersion, currentStorageVersion);
        });
        // The current storage version is too old to update
        if (neededUpdates.length > 0 &&
            version_1.isFirstVersionHigherThanSecond(version_1.parseVersionString(neededUpdates[0].fromVersion), currentStorageVersion)) {
            throw new error_1.AriesFrameworkError(`First fromVersion is higher than current storage version. You need to use an older version of the framework to update to at least version ${neededUpdates[0].fromVersion}`);
        }
        return neededUpdates;
    }
    async update() {
        const updateIdentifier = Date.now().toString();
        try {
            this.agent.config.logger.info(`Starting update of agent storage with updateIdentifier ${updateIdentifier}`);
            const neededUpdates = await this.getNeededUpdates();
            if (neededUpdates.length == 0) {
                this.agent.config.logger.info('No update needed. Agent storage is up to date.');
                return;
            }
            const fromVersion = neededUpdates[0].fromVersion;
            const toVersion = neededUpdates[neededUpdates.length - 1].toVersion;
            this.agent.config.logger.info(`Starting update process. Total of ${neededUpdates.length} update(s) will be applied to update the agent storage from version ${fromVersion} to version ${toVersion}`);
            // Create backup in case migration goes wrong
            await this.createBackup(updateIdentifier);
            try {
                for (const update of neededUpdates) {
                    this.agent.config.logger.info(`Starting update of agent storage from version ${update.fromVersion} to version ${update.toVersion}`);
                    await update.doUpdate(this.agent, this.updateConfig);
                    // Update the framework version in storage
                    await this.storageUpdateService.setCurrentStorageVersion(update.toVersion);
                    this.agent.config.logger.info(`Successfully updated agent storage from version ${update.fromVersion} to version ${update.toVersion}`);
                }
            }
            catch (error) {
                this.agent.config.logger.fatal('An error occurred while updating the wallet. Restoring backup', {
                    error,
                });
                // In the case of an error we want to restore the backup
                await this.restoreBackup(updateIdentifier);
                throw error;
            }
        }
        catch (error) {
            this.agent.config.logger.error(`Error updating storage (updateIdentifier: ${updateIdentifier})`, {
                cause: error,
            });
            throw new StorageUpdateError_1.StorageUpdateError(`Error updating storage (updateIdentifier: ${updateIdentifier}): ${error.message}`, {
                cause: error,
            });
        }
        return updateIdentifier;
    }
    getBackupPath(backupIdentifier) {
        const fileSystem = this.agent.config.fileSystem;
        return `${fileSystem.basePath}/afj/migration/backup/${backupIdentifier}`;
    }
    async createBackup(backupIdentifier) {
        var _a;
        const backupPath = this.getBackupPath(backupIdentifier);
        const walletKey = (_a = this.agent.wallet.walletConfig) === null || _a === void 0 ? void 0 : _a.key;
        if (!walletKey) {
            throw new error_1.AriesFrameworkError("Could not extract wallet key from wallet module. Can't create backup");
        }
        await this.agent.wallet.export({ key: walletKey, path: backupPath });
        this.agent.config.logger.info('Created backup of the wallet', {
            backupPath,
        });
    }
    async restoreBackup(backupIdentifier) {
        const backupPath = this.getBackupPath(backupIdentifier);
        const walletConfig = this.agent.wallet.walletConfig;
        if (!walletConfig) {
            throw new error_1.AriesFrameworkError('Could not extract wallet config from wallet module. Cannot restore backup');
        }
        // Export and delete current wallet
        await this.agent.wallet.export({ key: walletConfig.key, path: `${backupPath}-error` });
        await this.agent.wallet.delete();
        // Import backup
        await this.agent.wallet.import(walletConfig, { key: walletConfig.key, path: backupPath });
        await this.agent.wallet.initialize(walletConfig);
        this.agent.config.logger.info(`Successfully restored wallet from backup ${backupIdentifier}`, {
            backupPath,
        });
    }
}
exports.UpdateAssistant = UpdateAssistant;
//# sourceMappingURL=UpdateAssistant.js.map