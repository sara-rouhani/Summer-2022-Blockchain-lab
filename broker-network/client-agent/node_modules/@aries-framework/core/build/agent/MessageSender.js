"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var __asyncValues = (this && this.__asyncValues) || function (o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.isDidCommTransportQueue = exports.MessageSender = void 0;
const constants_1 = require("../constants");
const TransportDecorator_1 = require("../decorators/transport/TransportDecorator");
const error_1 = require("../error");
const dids_1 = require("../modules/dids");
const key_type_1 = require("../modules/dids/domain/key-type");
const service_1 = require("../modules/dids/domain/service");
const helpers_1 = require("../modules/dids/helpers");
const DidResolverService_1 = require("../modules/dids/services/DidResolverService");
const plugins_1 = require("../plugins");
const MessageValidator_1 = require("../utils/MessageValidator");
const uri_1 = require("../utils/uri");
const EnvelopeService_1 = require("./EnvelopeService");
const TransportService_1 = require("./TransportService");
let MessageSender = class MessageSender {
    constructor(envelopeService, transportService, messageRepository, logger, didResolverService) {
        this.outboundTransports = [];
        this.envelopeService = envelopeService;
        this.transportService = transportService;
        this.messageRepository = messageRepository;
        this.logger = logger;
        this.didResolverService = didResolverService;
        this.outboundTransports = [];
    }
    registerOutboundTransport(outboundTransport) {
        this.outboundTransports.push(outboundTransport);
    }
    async packMessage({ keys, message, endpoint, }) {
        const encryptedMessage = await this.envelopeService.packMessage(message, keys);
        return {
            payload: encryptedMessage,
            responseRequested: message.hasAnyReturnRoute(),
            endpoint,
        };
    }
    async sendMessageToSession(session, message) {
        this.logger.debug(`Existing ${session.type} transport session has been found.`);
        if (!session.keys) {
            throw new error_1.AriesFrameworkError(`There are no keys for the given ${session.type} transport session.`);
        }
        const encryptedMessage = await this.envelopeService.packMessage(message, session.keys);
        await session.send(encryptedMessage);
    }
    async sendPackage({ connection, encryptedMessage, options, }) {
        var e_1, _a;
        var _b;
        const errors = [];
        // Try to send to already open session
        const session = this.transportService.findSessionByConnectionId(connection.id);
        if ((_b = session === null || session === void 0 ? void 0 : session.inboundMessage) === null || _b === void 0 ? void 0 : _b.hasReturnRouting()) {
            try {
                await session.send(encryptedMessage);
                return;
            }
            catch (error) {
                errors.push(error);
                this.logger.debug(`Sending packed message via session failed with error: ${error.message}.`, error);
            }
        }
        // Retrieve DIDComm services
        const { services, queueService } = await this.retrieveServicesByConnection(connection, options === null || options === void 0 ? void 0 : options.transportPriority);
        if (this.outboundTransports.length === 0 && !queueService) {
            throw new error_1.AriesFrameworkError('Agent has no outbound transport!');
        }
        try {
            // Loop trough all available services and try to send the message
            for (var services_1 = __asyncValues(services), services_1_1; services_1_1 = await services_1.next(), !services_1_1.done;) {
                const service = services_1_1.value;
                this.logger.debug(`Sending outbound message to service:`, { service });
                try {
                    const protocolScheme = uri_1.getProtocolScheme(service.serviceEndpoint);
                    for (const transport of this.outboundTransports) {
                        if (transport.supportedSchemes.includes(protocolScheme)) {
                            await transport.sendMessage({
                                payload: encryptedMessage,
                                endpoint: service.serviceEndpoint,
                                connectionId: connection.id,
                            });
                            break;
                        }
                    }
                    return;
                }
                catch (error) {
                    this.logger.debug(`Sending outbound message to service with id ${service.id} failed with the following error:`, {
                        message: error.message,
                        error: error,
                    });
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (services_1_1 && !services_1_1.done && (_a = services_1.return)) await _a.call(services_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
        // We didn't succeed to send the message over open session, or directly to serviceEndpoint
        // If the other party shared a queue service endpoint in their did doc we queue the message
        if (queueService) {
            this.logger.debug(`Queue packed message for connection ${connection.id} (${connection.theirLabel})`);
            this.messageRepository.add(connection.id, encryptedMessage);
            return;
        }
        // Message is undeliverable
        this.logger.error(`Message is undeliverable to connection ${connection.id} (${connection.theirLabel})`, {
            message: encryptedMessage,
            errors,
            connection,
        });
        throw new error_1.AriesFrameworkError(`Message is undeliverable to connection ${connection.id} (${connection.theirLabel})`);
    }
    async sendMessage(outboundMessage, options) {
        var e_2, _a;
        var _b, _c;
        const { connection, outOfBand, sessionId, payload } = outboundMessage;
        const errors = [];
        this.logger.debug('Send outbound message', {
            message: payload,
            connectionId: connection.id,
        });
        let session;
        if (sessionId) {
            session = this.transportService.findSessionById(sessionId);
        }
        if (!session) {
            // Try to send to already open session
            session = this.transportService.findSessionByConnectionId(connection.id);
        }
        if ((_b = session === null || session === void 0 ? void 0 : session.inboundMessage) === null || _b === void 0 ? void 0 : _b.hasReturnRouting(payload.threadId)) {
            this.logger.debug(`Found session with return routing for message '${payload.id}' (connection '${connection.id}'`);
            try {
                await this.sendMessageToSession(session, payload);
                return;
            }
            catch (error) {
                errors.push(error);
                this.logger.debug(`Sending an outbound message via session failed with error: ${error.message}.`, error);
            }
        }
        // Retrieve DIDComm services
        const { services, queueService } = await this.retrieveServicesByConnection(connection, options === null || options === void 0 ? void 0 : options.transportPriority, outOfBand);
        if (!connection.did) {
            this.logger.error(`Unable to send message using connection '${connection.id}' that doesn't have a did`);
            throw new error_1.AriesFrameworkError(`Unable to send message using connection '${connection.id}' that doesn't have a did`);
        }
        const ourDidDocument = await this.didResolverService.resolveDidDocument(connection.did);
        const ourAuthenticationKeys = getAuthenticationKeys(ourDidDocument);
        // TODO We're selecting just the first authentication key. Is it ok?
        // We can probably learn something from the didcomm-rust implementation, which looks at crypto compatibility to make sure the
        // other party can decrypt the message. https://github.com/sicpa-dlab/didcomm-rust/blob/9a24b3b60f07a11822666dda46e5616a138af056/src/message/pack_encrypted/mod.rs#L33-L44
        // This will become more relevant when we support different encrypt envelopes. One thing to take into account though is that currently we only store the recipientKeys
        // as defined in the didcomm services, while it could be for example that the first authentication key is not defined in the recipientKeys, in which case we wouldn't
        // even be interoperable between two AFJ agents. So we should either pick the first key that is defined in the recipientKeys, or we should make sure to store all
        // keys defined in the did document as tags so we can retrieve it, even if it's not defined in the recipientKeys. This, again, will become simpler once we use didcomm v2
        // as the `from` field in a received message will identity the did used so we don't have to store all keys in tags to be able to find the connections associated with
        // an incoming message.
        const [firstOurAuthenticationKey] = ourAuthenticationKeys;
        // If the returnRoute is already set we won't override it. This allows to set the returnRoute manually if this is desired.
        const shouldAddReturnRoute = ((_c = payload.transport) === null || _c === void 0 ? void 0 : _c.returnRoute) === undefined && !this.transportService.hasInboundEndpoint(ourDidDocument);
        try {
            // Loop trough all available services and try to send the message
            for (var services_2 = __asyncValues(services), services_2_1; services_2_1 = await services_2.next(), !services_2_1.done;) {
                const service = services_2_1.value;
                try {
                    // Enable return routing if the our did document does not have any inbound endpoint for given sender key
                    await this.sendMessageToService({
                        message: payload,
                        service,
                        senderKey: firstOurAuthenticationKey,
                        returnRoute: shouldAddReturnRoute,
                        connectionId: connection.id,
                    });
                    return;
                }
                catch (error) {
                    errors.push(error);
                    this.logger.debug(`Sending outbound message to service with id ${service.id} failed with the following error:`, {
                        message: error.message,
                        error: error,
                    });
                }
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (services_2_1 && !services_2_1.done && (_a = services_2.return)) await _a.call(services_2);
            }
            finally { if (e_2) throw e_2.error; }
        }
        // We didn't succeed to send the message over open session, or directly to serviceEndpoint
        // If the other party shared a queue service endpoint in their did doc we queue the message
        if (queueService) {
            this.logger.debug(`Queue message for connection ${connection.id} (${connection.theirLabel})`);
            const keys = {
                recipientKeys: queueService.recipientKeys,
                routingKeys: queueService.routingKeys,
                senderKey: firstOurAuthenticationKey,
            };
            const encryptedMessage = await this.envelopeService.packMessage(payload, keys);
            this.messageRepository.add(connection.id, encryptedMessage);
            return;
        }
        // Message is undeliverable
        this.logger.error(`Message is undeliverable to connection ${connection.id} (${connection.theirLabel})`, {
            message: payload,
            errors,
            connection,
        });
        throw new error_1.AriesFrameworkError(`Message is undeliverable to connection ${connection.id} (${connection.theirLabel})`);
    }
    async sendMessageToService({ message, service, senderKey, returnRoute, connectionId, }) {
        if (this.outboundTransports.length === 0) {
            throw new error_1.AriesFrameworkError('Agent has no outbound transport!');
        }
        this.logger.debug(`Sending outbound message to service:`, {
            messageId: message.id,
            service: Object.assign(Object.assign({}, service), { recipientKeys: 'omitted...', routingKeys: 'omitted...' }),
        });
        const keys = {
            recipientKeys: service.recipientKeys,
            routingKeys: service.routingKeys,
            senderKey,
        };
        // Set return routing for message if requested
        if (returnRoute) {
            message.setReturnRouting(TransportDecorator_1.ReturnRouteTypes.all);
        }
        try {
            MessageValidator_1.MessageValidator.validateSync(message);
        }
        catch (error) {
            this.logger.error(`Aborting sending outbound message ${message.type} to ${service.serviceEndpoint}. Message validation failed`, {
                errors: error,
                message: message.toJSON(),
            });
            throw error;
        }
        const outboundPackage = await this.packMessage({ message, keys, endpoint: service.serviceEndpoint });
        outboundPackage.endpoint = service.serviceEndpoint;
        outboundPackage.connectionId = connectionId;
        for (const transport of this.outboundTransports) {
            const protocolScheme = uri_1.getProtocolScheme(service.serviceEndpoint);
            if (!protocolScheme) {
                this.logger.warn('Service does not have valid protocolScheme.');
            }
            else if (transport.supportedSchemes.includes(protocolScheme)) {
                await transport.sendMessage(outboundPackage);
                return;
            }
        }
        throw new error_1.AriesFrameworkError(`Unable to send message to service: ${service.serviceEndpoint}`);
    }
    async retrieveServicesFromDid(did) {
        var _a, _b;
        this.logger.debug(`Resolving services for did ${did}.`);
        const didDocument = await this.didResolverService.resolveDidDocument(did);
        const didCommServices = [];
        // FIXME: we currently retrieve did documents for all didcomm services in the did document, and we don't have caching
        // yet so this will re-trigger ledger resolves for each one. Should we only resolve the first service, then the second service, etc...?
        for (const didCommService of didDocument.didCommServices) {
            if (didCommService instanceof service_1.IndyAgentService) {
                // IndyAgentService (DidComm v0) has keys encoded as raw publicKeyBase58 (verkeys)
                didCommServices.push({
                    id: didCommService.id,
                    recipientKeys: didCommService.recipientKeys.map(helpers_1.verkeyToInstanceOfKey),
                    routingKeys: ((_a = didCommService.routingKeys) === null || _a === void 0 ? void 0 : _a.map(helpers_1.verkeyToInstanceOfKey)) || [],
                    serviceEndpoint: didCommService.serviceEndpoint,
                });
            }
            else if (didCommService instanceof service_1.DidCommV1Service) {
                // Resolve dids to DIDDocs to retrieve routingKeys
                const routingKeys = [];
                for (const routingKey of (_b = didCommService.routingKeys) !== null && _b !== void 0 ? _b : []) {
                    const routingDidDocument = await this.didResolverService.resolveDidDocument(routingKey);
                    routingKeys.push(dids_1.keyReferenceToKey(routingDidDocument, routingKey));
                }
                // Dereference recipientKeys
                const recipientKeys = didCommService.recipientKeys.map((recipientKey) => dids_1.keyReferenceToKey(didDocument, recipientKey));
                // DidCommV1Service has keys encoded as key references
                didCommServices.push({
                    id: didCommService.id,
                    recipientKeys,
                    routingKeys,
                    serviceEndpoint: didCommService.serviceEndpoint,
                });
            }
        }
        return didCommServices;
    }
    async retrieveServicesByConnection(connection, transportPriority, outOfBand) {
        var _a;
        this.logger.debug(`Retrieving services for connection '${connection.id}' (${connection.theirLabel})`, {
            transportPriority,
            connection,
        });
        let didCommServices = [];
        if (connection.theirDid) {
            this.logger.debug(`Resolving services for connection theirDid ${connection.theirDid}.`);
            didCommServices = await this.retrieveServicesFromDid(connection.theirDid);
        }
        else if (outOfBand) {
            this.logger.debug(`Resolving services from out-of-band record ${outOfBand === null || outOfBand === void 0 ? void 0 : outOfBand.id}.`);
            if (connection.isRequester) {
                for (const service of outOfBand.outOfBandInvitation.services) {
                    // Resolve dids to DIDDocs to retrieve services
                    if (typeof service === 'string') {
                        didCommServices = await this.retrieveServicesFromDid(service);
                    }
                    else {
                        // Out of band inline service contains keys encoded as did:key references
                        didCommServices.push({
                            id: service.id,
                            recipientKeys: service.recipientKeys.map(helpers_1.didKeyToInstanceOfKey),
                            routingKeys: ((_a = service.routingKeys) === null || _a === void 0 ? void 0 : _a.map(helpers_1.didKeyToInstanceOfKey)) || [],
                            serviceEndpoint: service.serviceEndpoint,
                        });
                    }
                }
            }
        }
        // Separate queue service out
        let services = didCommServices.filter((s) => !isDidCommTransportQueue(s.serviceEndpoint));
        const queueService = didCommServices.find((s) => isDidCommTransportQueue(s.serviceEndpoint));
        // If restrictive will remove services not listed in schemes list
        if (transportPriority === null || transportPriority === void 0 ? void 0 : transportPriority.restrictive) {
            services = services.filter((service) => {
                const serviceSchema = uri_1.getProtocolScheme(service.serviceEndpoint);
                return transportPriority.schemes.includes(serviceSchema);
            });
        }
        // If transport priority is set we will sort services by our priority
        if (transportPriority === null || transportPriority === void 0 ? void 0 : transportPriority.schemes) {
            services = services.sort(function (a, b) {
                const aScheme = uri_1.getProtocolScheme(a.serviceEndpoint);
                const bScheme = uri_1.getProtocolScheme(b.serviceEndpoint);
                return (transportPriority === null || transportPriority === void 0 ? void 0 : transportPriority.schemes.indexOf(aScheme)) - (transportPriority === null || transportPriority === void 0 ? void 0 : transportPriority.schemes.indexOf(bScheme));
            });
        }
        this.logger.debug(`Retrieved ${services.length} services for message to connection '${connection.id}'(${connection.theirLabel})'`, { hasQueueService: queueService !== undefined });
        return { services, queueService };
    }
};
MessageSender = __decorate([
    plugins_1.injectable(),
    __param(2, plugins_1.inject(constants_1.InjectionSymbols.MessageRepository)),
    __param(3, plugins_1.inject(constants_1.InjectionSymbols.Logger)),
    __metadata("design:paramtypes", [EnvelopeService_1.EnvelopeService,
        TransportService_1.TransportService, Object, Object, DidResolverService_1.DidResolverService])
], MessageSender);
exports.MessageSender = MessageSender;
function isDidCommTransportQueue(serviceEndpoint) {
    return serviceEndpoint === constants_1.DID_COMM_TRANSPORT_QUEUE;
}
exports.isDidCommTransportQueue = isDidCommTransportQueue;
function getAuthenticationKeys(didDocument) {
    var _a, _b;
    return ((_b = (_a = didDocument.authentication) === null || _a === void 0 ? void 0 : _a.map((authentication) => {
        const verificationMethod = typeof authentication === 'string' ? didDocument.dereferenceVerificationMethod(authentication) : authentication;
        const { getKeyFromVerificationMethod } = key_type_1.getKeyDidMappingByVerificationMethod(verificationMethod);
        const key = getKeyFromVerificationMethod(verificationMethod);
        return key;
    })) !== null && _b !== void 0 ? _b : []);
}
//# sourceMappingURL=MessageSender.js.map