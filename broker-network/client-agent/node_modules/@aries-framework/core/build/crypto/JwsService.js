"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.JwsService = void 0;
const constants_1 = require("../constants");
const error_1 = require("../error");
const plugins_1 = require("../plugins");
const utils_1 = require("../utils");
const error_2 = require("../wallet/error");
// TODO: support more key types, more generic jws format
const JWS_KEY_TYPE = 'OKP';
const JWS_CURVE = 'Ed25519';
const JWS_ALG = 'EdDSA';
let JwsService = class JwsService {
    constructor(wallet) {
        this.wallet = wallet;
    }
    async createJws({ payload, verkey, header }) {
        const base64Payload = utils_1.TypedArrayEncoder.toBase64URL(payload);
        const base64Protected = utils_1.JsonEncoder.toBase64URL(this.buildProtected(verkey));
        const signature = utils_1.TypedArrayEncoder.toBase64URL(await this.wallet.sign(utils_1.TypedArrayEncoder.fromString(`${base64Protected}.${base64Payload}`), verkey));
        return {
            protected: base64Protected,
            signature,
            header,
        };
    }
    /**
     * Verify a a JWS
     */
    async verifyJws({ jws, payload }) {
        var _a, _b, _c;
        const base64Payload = utils_1.TypedArrayEncoder.toBase64URL(payload);
        const signatures = 'signatures' in jws ? jws.signatures : [jws];
        if (signatures.length === 0) {
            throw new error_1.AriesFrameworkError('Unable to verify JWS: No entries in JWS signatures array.');
        }
        const signerVerkeys = [];
        for (const jws of signatures) {
            const protectedJson = utils_1.JsonEncoder.fromBase64(jws.protected);
            const isValidKeyType = ((_a = protectedJson === null || protectedJson === void 0 ? void 0 : protectedJson.jwk) === null || _a === void 0 ? void 0 : _a.kty) === JWS_KEY_TYPE;
            const isValidCurve = ((_b = protectedJson === null || protectedJson === void 0 ? void 0 : protectedJson.jwk) === null || _b === void 0 ? void 0 : _b.crv) === JWS_CURVE;
            const isValidAlg = (protectedJson === null || protectedJson === void 0 ? void 0 : protectedJson.alg) === JWS_ALG;
            if (!isValidKeyType || !isValidCurve || !isValidAlg) {
                throw new error_1.AriesFrameworkError('Invalid protected header');
            }
            const data = utils_1.TypedArrayEncoder.fromString(`${jws.protected}.${base64Payload}`);
            const signature = utils_1.TypedArrayEncoder.fromBase64(jws.signature);
            const verkey = utils_1.TypedArrayEncoder.toBase58(utils_1.TypedArrayEncoder.fromBase64((_c = protectedJson === null || protectedJson === void 0 ? void 0 : protectedJson.jwk) === null || _c === void 0 ? void 0 : _c.x));
            signerVerkeys.push(verkey);
            try {
                const isValid = await this.wallet.verify(verkey, data, signature);
                if (!isValid) {
                    return {
                        isValid: false,
                        signerVerkeys: [],
                    };
                }
            }
            catch (error) {
                // WalletError probably means signature verification failed. Would be useful to add
                // more specific error type in wallet.verify method
                if (error instanceof error_2.WalletError) {
                    return {
                        isValid: false,
                        signerVerkeys: [],
                    };
                }
                throw error;
            }
        }
        return { isValid: true, signerVerkeys };
    }
    /**
     * @todo This currently only work with a single alg, key type and curve
     *    This needs to be extended with other formats in the future
     */
    buildProtected(verkey) {
        return {
            alg: 'EdDSA',
            jwk: {
                kty: 'OKP',
                crv: 'Ed25519',
                x: utils_1.TypedArrayEncoder.toBase64URL(utils_1.TypedArrayEncoder.fromBase58(verkey)),
            },
        };
    }
};
JwsService = __decorate([
    plugins_1.injectable(),
    __param(0, plugins_1.inject(constants_1.InjectionSymbols.Wallet)),
    __metadata("design:paramtypes", [Object])
], JwsService);
exports.JwsService = JwsService;
//# sourceMappingURL=JwsService.js.map