"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var CredentialsModule_1;
Object.defineProperty(exports, "__esModule", { value: true });
exports.CredentialsModule = void 0;
const AgentConfig_1 = require("../../agent/AgentConfig");
const MessageSender_1 = require("../../agent/MessageSender");
const helpers_1 = require("../../agent/helpers");
const ServiceDecorator_1 = require("../../decorators/service/ServiceDecorator");
const error_1 = require("../../error");
const plugins_1 = require("../../plugins");
const storage_1 = require("../../storage");
const DidCommMessageRepository_1 = require("../../storage/didcomm/DidCommMessageRepository");
const services_1 = require("../connections/services");
const RoutingService_1 = require("../routing/services/RoutingService");
const formats_1 = require("./formats");
const CredentialState_1 = require("./models/CredentialState");
const V1CredentialService_1 = require("./protocol/v1/V1CredentialService");
const V2CredentialService_1 = require("./protocol/v2/V2CredentialService");
const CredentialRepository_1 = require("./repository/CredentialRepository");
const services_2 = require("./services");
let CredentialsModule = CredentialsModule_1 = class CredentialsModule {
    constructor(messageSender, connectionService, agentConfig, credentialRepository, mediationRecipientService, didCommMessageRepository, v1Service, v2Service, 
    // only injected so the handlers will be registered
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    _revocationNotificationService) {
        this.messageSender = messageSender;
        this.connectionService = connectionService;
        this.credentialRepository = credentialRepository;
        this.agentConfig = agentConfig;
        this.routingService = mediationRecipientService;
        this.didCommMessageRepo = didCommMessageRepository;
        this.logger = agentConfig.logger;
        // Dynamically build service map. This will be extracted once services are registered dynamically
        this.serviceMap = [v1Service, v2Service].reduce((serviceMap, service) => (Object.assign(Object.assign({}, serviceMap), { [service.version]: service })), {});
        this.logger.debug(`Initializing Credentials Module for agent ${this.agentConfig.label}`);
    }
    getService(protocolVersion) {
        if (!this.serviceMap[protocolVersion]) {
            throw new error_1.AriesFrameworkError(`No credential service registered for protocol version ${protocolVersion}`);
        }
        return this.serviceMap[protocolVersion];
    }
    /**
     * Initiate a new credential exchange as holder by sending a credential proposal message
     * to the connection with the specified credential options
     *
     * @param options configuration to use for the proposal
     * @returns Credential exchange record associated with the sent proposal message
     */
    async proposeCredential(options) {
        const service = this.getService(options.protocolVersion);
        this.logger.debug(`Got a CredentialService object for version ${options.protocolVersion}`);
        const connection = await this.connectionService.getById(options.connectionId);
        // will get back a credential record -> map to Credential Exchange Record
        const { credentialRecord, message } = await service.createProposal({
            connection,
            credentialFormats: options.credentialFormats,
            comment: options.comment,
            autoAcceptCredential: options.autoAcceptCredential,
        });
        this.logger.debug('We have a message (sending outbound): ', message);
        // send the message here
        const outbound = helpers_1.createOutboundMessage(connection, message);
        this.logger.debug('In proposeCredential: Send Proposal to Issuer');
        await this.messageSender.sendMessage(outbound);
        return credentialRecord;
    }
    /**
     * Accept a credential proposal as issuer (by sending a credential offer message) to the connection
     * associated with the credential record.
     *
     * @param options config object for accepting the proposal
     * @returns Credential exchange record associated with the credential offer
     *
     */
    async acceptProposal(options) {
        const credentialRecord = await this.getById(options.credentialRecordId);
        if (!credentialRecord.connectionId) {
            throw new error_1.AriesFrameworkError(`No connectionId found for credential record '${credentialRecord.id}'. Connection-less issuance does not support credential proposal or negotiation.`);
        }
        // with version we can get the Service
        const service = this.getService(credentialRecord.protocolVersion);
        // will get back a credential record -> map to Credential Exchange Record
        const { message } = await service.acceptProposal({
            credentialRecord,
            credentialFormats: options.credentialFormats,
            comment: options.comment,
            autoAcceptCredential: options.autoAcceptCredential,
        });
        // send the message
        const connection = await this.connectionService.getById(credentialRecord.connectionId);
        const outbound = helpers_1.createOutboundMessage(connection, message);
        await this.messageSender.sendMessage(outbound);
        return credentialRecord;
    }
    /**
     * Negotiate a credential proposal as issuer (by sending a credential offer message) to the connection
     * associated with the credential record.
     *
     * @param options configuration for the offer see {@link NegotiateProposalOptions}
     * @returns Credential exchange record associated with the credential offer
     *
     */
    async negotiateProposal(options) {
        const credentialRecord = await this.getById(options.credentialRecordId);
        if (!credentialRecord.connectionId) {
            throw new error_1.AriesFrameworkError(`No connection id for credential record ${credentialRecord.id} not found. Connection-less issuance does not support negotiation`);
        }
        // with version we can get the Service
        const service = this.getService(credentialRecord.protocolVersion);
        const { message } = await service.negotiateProposal({
            credentialRecord,
            credentialFormats: options.credentialFormats,
            comment: options.comment,
            autoAcceptCredential: options.autoAcceptCredential,
        });
        const connection = await this.connectionService.getById(credentialRecord.connectionId);
        const outboundMessage = helpers_1.createOutboundMessage(connection, message);
        await this.messageSender.sendMessage(outboundMessage);
        return credentialRecord;
    }
    /**
     * Initiate a new credential exchange as issuer by sending a credential offer message
     * to the connection with the specified connection id.
     *
     * @param options config options for the credential offer
     * @returns Credential exchange record associated with the sent credential offer message
     */
    async offerCredential(options) {
        const connection = await this.connectionService.getById(options.connectionId);
        const service = this.getService(options.protocolVersion);
        this.logger.debug(`Got a CredentialService object for version ${options.protocolVersion}`);
        const { message, credentialRecord } = await service.createOffer({
            credentialFormats: options.credentialFormats,
            autoAcceptCredential: options.autoAcceptCredential,
            comment: options.comment,
            connection,
        });
        this.logger.debug('Offer Message successfully created; message= ', message);
        const outboundMessage = helpers_1.createOutboundMessage(connection, message);
        await this.messageSender.sendMessage(outboundMessage);
        return credentialRecord;
    }
    /**
     * Accept a credential offer as holder (by sending a credential request message) to the connection
     * associated with the credential record.
     *
     * @param options The object containing config options of the offer to be accepted
     * @returns Object containing offer associated credential record
     */
    async acceptOffer(options) {
        const credentialRecord = await this.getById(options.credentialRecordId);
        const service = this.getService(credentialRecord.protocolVersion);
        this.logger.debug(`Got a CredentialService object for this version; version = ${service.version}`);
        const offerMessage = await service.findOfferMessage(credentialRecord.id);
        // Use connection if present
        if (credentialRecord.connectionId) {
            const connection = await this.connectionService.getById(credentialRecord.connectionId);
            const { message } = await service.acceptOffer({
                credentialRecord,
                credentialFormats: options.credentialFormats,
                comment: options.comment,
                autoAcceptCredential: options.autoAcceptCredential,
            });
            const outboundMessage = helpers_1.createOutboundMessage(connection, message);
            await this.messageSender.sendMessage(outboundMessage);
            return credentialRecord;
        }
        // Use ~service decorator otherwise
        else if (offerMessage === null || offerMessage === void 0 ? void 0 : offerMessage.service) {
            // Create ~service decorator
            const routing = await this.routingService.getRouting();
            const ourService = new ServiceDecorator_1.ServiceDecorator({
                serviceEndpoint: routing.endpoints[0],
                recipientKeys: [routing.recipientKey.publicKeyBase58],
                routingKeys: routing.routingKeys.map((key) => key.publicKeyBase58),
            });
            const recipientService = offerMessage.service;
            const { message } = await service.acceptOffer({
                credentialRecord,
                credentialFormats: options.credentialFormats,
                comment: options.comment,
                autoAcceptCredential: options.autoAcceptCredential,
            });
            // Set and save ~service decorator to record (to remember our verkey)
            message.service = ourService;
            await this.didCommMessageRepo.saveOrUpdateAgentMessage({
                agentMessage: message,
                role: storage_1.DidCommMessageRole.Sender,
                associatedRecordId: credentialRecord.id,
            });
            await this.messageSender.sendMessageToService({
                message,
                service: recipientService.resolvedDidCommService,
                senderKey: ourService.resolvedDidCommService.recipientKeys[0],
                returnRoute: true,
            });
            return credentialRecord;
        }
        // Cannot send message without connectionId or ~service decorator
        else {
            throw new error_1.AriesFrameworkError(`Cannot accept offer for credential record without connectionId or ~service decorator on credential offer.`);
        }
    }
    async declineOffer(credentialRecordId) {
        const credentialRecord = await this.getById(credentialRecordId);
        credentialRecord.assertState(CredentialState_1.CredentialState.OfferReceived);
        // with version we can get the Service
        const service = this.getService(credentialRecord.protocolVersion);
        await service.updateState(credentialRecord, CredentialState_1.CredentialState.Declined);
        return credentialRecord;
    }
    async negotiateOffer(options) {
        const credentialRecord = await this.getById(options.credentialRecordId);
        const service = this.getService(credentialRecord.protocolVersion);
        const { message } = await service.negotiateOffer({
            credentialFormats: options.credentialFormats,
            credentialRecord,
            comment: options.comment,
            autoAcceptCredential: options.autoAcceptCredential,
        });
        if (!credentialRecord.connectionId) {
            throw new error_1.AriesFrameworkError(`No connection id for credential record ${credentialRecord.id} not found. Connection-less issuance does not support negotiation`);
        }
        const connection = await this.connectionService.getById(credentialRecord.connectionId);
        const outboundMessage = helpers_1.createOutboundMessage(connection, message);
        await this.messageSender.sendMessage(outboundMessage);
        return credentialRecord;
    }
    /**
     * Initiate a new credential exchange as issuer by creating a credential offer
     * not bound to any connection. The offer must be delivered out-of-band to the holder
     * @param options The credential options to use for the offer
     * @returns The credential record and credential offer message
     */
    async createOffer(options) {
        const service = this.getService(options.protocolVersion);
        this.logger.debug(`Got a CredentialService object for version ${options.protocolVersion}`);
        const { message, credentialRecord } = await service.createOffer({
            credentialFormats: options.credentialFormats,
            comment: options.comment,
            autoAcceptCredential: options.autoAcceptCredential,
        });
        this.logger.debug('Offer Message successfully created; message= ', message);
        return { message, credentialRecord };
    }
    /**
     * Accept a credential request as holder (by sending a credential request message) to the connection
     * associated with the credential record.
     *
     * @param options The object containing config options of the request
     * @returns CredentialExchangeRecord updated with information pertaining to this request
     */
    async acceptRequest(options) {
        const credentialRecord = await this.getById(options.credentialRecordId);
        // with version we can get the Service
        const service = this.getService(credentialRecord.protocolVersion);
        this.logger.debug(`Got a CredentialService object for version ${credentialRecord.protocolVersion}`);
        const { message } = await service.acceptRequest({
            credentialRecord,
            credentialFormats: options.credentialFormats,
            comment: options.comment,
            autoAcceptCredential: options.autoAcceptCredential,
        });
        this.logger.debug('We have a credential message (sending outbound): ', message);
        const requestMessage = await service.findRequestMessage(credentialRecord.id);
        const offerMessage = await service.findOfferMessage(credentialRecord.id);
        // Use connection if present
        if (credentialRecord.connectionId) {
            const connection = await this.connectionService.getById(credentialRecord.connectionId);
            const outboundMessage = helpers_1.createOutboundMessage(connection, message);
            await this.messageSender.sendMessage(outboundMessage);
            return credentialRecord;
        }
        // Use ~service decorator otherwise
        else if ((requestMessage === null || requestMessage === void 0 ? void 0 : requestMessage.service) && (offerMessage === null || offerMessage === void 0 ? void 0 : offerMessage.service)) {
            const recipientService = requestMessage.service;
            const ourService = offerMessage.service;
            message.service = ourService;
            await this.didCommMessageRepo.saveOrUpdateAgentMessage({
                agentMessage: message,
                role: storage_1.DidCommMessageRole.Sender,
                associatedRecordId: credentialRecord.id,
            });
            await this.messageSender.sendMessageToService({
                message,
                service: recipientService.resolvedDidCommService,
                senderKey: ourService.resolvedDidCommService.recipientKeys[0],
                returnRoute: true,
            });
            return credentialRecord;
        }
        // Cannot send message without connectionId or ~service decorator
        else {
            throw new error_1.AriesFrameworkError(`Cannot accept request for credential record without connectionId or ~service decorator on credential offer / request.`);
        }
    }
    /**
     * Accept a credential as holder (by sending a credential acknowledgement message) to the connection
     * associated with the credential record.
     *
     * @param credentialRecordId The id of the credential record for which to accept the credential
     * @returns credential exchange record associated with the sent credential acknowledgement message
     *
     */
    async acceptCredential(options) {
        const credentialRecord = await this.getById(options.credentialRecordId);
        // with version we can get the Service
        const service = this.getService(credentialRecord.protocolVersion);
        this.logger.debug(`Got a CredentialService object for version ${credentialRecord.protocolVersion}`);
        const { message } = await service.acceptCredential({
            credentialRecord,
        });
        const requestMessage = await service.findRequestMessage(credentialRecord.id);
        const credentialMessage = await service.findCredentialMessage(credentialRecord.id);
        if (credentialRecord.connectionId) {
            const connection = await this.connectionService.getById(credentialRecord.connectionId);
            const outboundMessage = helpers_1.createOutboundMessage(connection, message);
            await this.messageSender.sendMessage(outboundMessage);
            return credentialRecord;
        }
        // Use ~service decorator otherwise
        else if ((credentialMessage === null || credentialMessage === void 0 ? void 0 : credentialMessage.service) && (requestMessage === null || requestMessage === void 0 ? void 0 : requestMessage.service)) {
            const recipientService = credentialMessage.service;
            const ourService = requestMessage.service;
            await this.messageSender.sendMessageToService({
                message,
                service: recipientService.resolvedDidCommService,
                senderKey: ourService.resolvedDidCommService.recipientKeys[0],
                returnRoute: true,
            });
            return credentialRecord;
        }
        // Cannot send message without connectionId or ~service decorator
        else {
            throw new error_1.AriesFrameworkError(`Cannot accept credential without connectionId or ~service decorator on credential message.`);
        }
    }
    /**
     * Send problem report message for a credential record
     * @param credentialRecordId The id of the credential record for which to send problem report
     * @param message message to send
     * @returns credential record associated with the credential problem report message
     */
    async sendProblemReport(options) {
        const credentialRecord = await this.getById(options.credentialRecordId);
        if (!credentialRecord.connectionId) {
            throw new error_1.AriesFrameworkError(`No connectionId found for credential record '${credentialRecord.id}'.`);
        }
        const connection = await this.connectionService.getById(credentialRecord.connectionId);
        const service = this.getService(credentialRecord.protocolVersion);
        const problemReportMessage = service.createProblemReport({ message: options.message });
        problemReportMessage.setThread({
            threadId: credentialRecord.threadId,
        });
        const outboundMessage = helpers_1.createOutboundMessage(connection, problemReportMessage);
        await this.messageSender.sendMessage(outboundMessage);
        return credentialRecord;
    }
    async getFormatData(credentialRecordId) {
        const credentialRecord = await this.getById(credentialRecordId);
        const service = this.getService(credentialRecord.protocolVersion);
        return service.getFormatData(credentialRecordId);
    }
    /**
     * Retrieve a credential record by id
     *
     * @param credentialRecordId The credential record id
     * @throws {RecordNotFoundError} If no record is found
     * @return The credential record
     *
     */
    getById(credentialRecordId) {
        return this.credentialRepository.getById(credentialRecordId);
    }
    /**
     * Retrieve all credential records
     *
     * @returns List containing all credential records
     */
    getAll() {
        return this.credentialRepository.getAll();
    }
    /**
     * Find a credential record by id
     *
     * @param credentialRecordId the credential record id
     * @returns The credential record or null if not found
     */
    findById(credentialRecordId) {
        return this.credentialRepository.findById(credentialRecordId);
    }
    /**
     * Delete a credential record by id, also calls service to delete from wallet
     *
     * @param credentialId the credential record id
     * @param options the delete credential options for the delete operation
     */
    async deleteById(credentialId, options) {
        const credentialRecord = await this.getById(credentialId);
        const service = this.getService(credentialRecord.protocolVersion);
        return service.delete(credentialRecord, options);
    }
    async findProposalMessage(credentialExchangeId) {
        const service = await this.getServiceForCredentialExchangeId(credentialExchangeId);
        return service.findProposalMessage(credentialExchangeId);
    }
    async findOfferMessage(credentialExchangeId) {
        const service = await this.getServiceForCredentialExchangeId(credentialExchangeId);
        return service.findOfferMessage(credentialExchangeId);
    }
    async findRequestMessage(credentialExchangeId) {
        const service = await this.getServiceForCredentialExchangeId(credentialExchangeId);
        return service.findRequestMessage(credentialExchangeId);
    }
    async findCredentialMessage(credentialExchangeId) {
        const service = await this.getServiceForCredentialExchangeId(credentialExchangeId);
        return service.findCredentialMessage(credentialExchangeId);
    }
    async getServiceForCredentialExchangeId(credentialExchangeId) {
        const credentialExchangeRecord = await this.getById(credentialExchangeId);
        return this.getService(credentialExchangeRecord.protocolVersion);
    }
    /**
     * Registers the dependencies of the credentials module on the dependency manager.
     */
    static register(dependencyManager) {
        // Api
        dependencyManager.registerContextScoped(CredentialsModule_1);
        // Services
        dependencyManager.registerSingleton(V1CredentialService_1.V1CredentialService);
        dependencyManager.registerSingleton(services_2.RevocationNotificationService);
        dependencyManager.registerSingleton(V2CredentialService_1.V2CredentialService);
        // Repositories
        dependencyManager.registerSingleton(CredentialRepository_1.CredentialRepository);
        // Credential Formats
        dependencyManager.registerSingleton(formats_1.IndyCredentialFormatService);
    }
};
CredentialsModule = CredentialsModule_1 = __decorate([
    plugins_1.module(),
    plugins_1.injectable(),
    __metadata("design:paramtypes", [MessageSender_1.MessageSender,
        services_1.ConnectionService,
        AgentConfig_1.AgentConfig,
        CredentialRepository_1.CredentialRepository,
        RoutingService_1.RoutingService,
        DidCommMessageRepository_1.DidCommMessageRepository,
        V1CredentialService_1.V1CredentialService,
        V2CredentialService_1.V2CredentialService,
        services_2.RevocationNotificationService])
], CredentialsModule);
exports.CredentialsModule = CredentialsModule;
//# sourceMappingURL=CredentialsModule.js.map