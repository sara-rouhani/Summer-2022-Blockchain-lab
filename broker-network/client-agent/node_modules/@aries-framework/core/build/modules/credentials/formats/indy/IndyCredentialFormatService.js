"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.IndyCredentialFormatService = void 0;
const AgentConfig_1 = require("../../../../agent/AgentConfig");
const EventEmitter_1 = require("../../../../agent/EventEmitter");
const constants_1 = require("../../../../constants");
const error_1 = require("../../../../error");
const plugins_1 = require("../../../../plugins");
const JsonTransformer_1 = require("../../../../utils/JsonTransformer");
const MessageValidator_1 = require("../../../../utils/MessageValidator");
const did_1 = require("../../../../utils/did");
const uuid_1 = require("../../../../utils/uuid");
const connections_1 = require("../../../connections");
const dids_1 = require("../../../dids");
const indy_1 = require("../../../indy");
const ledger_1 = require("../../../ledger");
const errors_1 = require("../../errors");
const CredentialFormatSpec_1 = require("../../models/CredentialFormatSpec");
const CredentialPreviewAttribute_1 = require("../../models/CredentialPreviewAttribute");
const CredentialMetadataTypes_1 = require("../../repository/CredentialMetadataTypes");
const CredentialRepository_1 = require("../../repository/CredentialRepository");
const CredentialFormatService_1 = require("../CredentialFormatService");
const IndyCredentialUtils_1 = require("./IndyCredentialUtils");
const IndyCredPropose_1 = require("./models/IndyCredPropose");
const INDY_CRED_ABSTRACT = 'hlindy/cred-abstract@v2.0';
const INDY_CRED_REQUEST = 'hlindy/cred-req@v2.0';
const INDY_CRED_FILTER = 'hlindy/cred-filter@v2.0';
const INDY_CRED = 'hlindy/cred@v2.0';
let IndyCredentialFormatService = class IndyCredentialFormatService extends CredentialFormatService_1.CredentialFormatService {
    constructor(credentialRepository, eventEmitter, indyIssuerService, indyLedgerService, indyHolderService, connectionService, didResolver, agentConfig, wallet) {
        super(credentialRepository, eventEmitter);
        this.formatKey = 'indy';
        this.credentialRecordType = 'indy';
        this.indyIssuerService = indyIssuerService;
        this.indyLedgerService = indyLedgerService;
        this.indyHolderService = indyHolderService;
        this.connectionService = connectionService;
        this.didResolver = didResolver;
        this.wallet = wallet;
        this.logger = agentConfig.logger;
    }
    /**
     * Create a {@link AttachmentFormats} object dependent on the message type.
     *
     * @param options The object containing all the options for the proposed credential
     * @returns object containing associated attachment, format and optionally the credential preview
     *
     */
    async createProposal({ credentialFormats, credentialRecord, }) {
        const format = new CredentialFormatSpec_1.CredentialFormatSpec({
            format: INDY_CRED_FILTER,
        });
        const indyFormat = credentialFormats.indy;
        if (!indyFormat) {
            throw new error_1.AriesFrameworkError('Missing indy payload createProposal');
        }
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        const { attributes, linkedAttachments } = indyFormat, indyCredentialProposal = __rest(indyFormat, ["attributes", "linkedAttachments"]);
        const proposal = new IndyCredPropose_1.IndyCredPropose(indyCredentialProposal);
        try {
            MessageValidator_1.MessageValidator.validateSync(proposal);
        }
        catch (error) {
            throw new error_1.AriesFrameworkError(`Invalid proposal supplied: ${indyCredentialProposal} in Indy Format Service`);
        }
        const proposalJson = JsonTransformer_1.JsonTransformer.toJSON(proposal);
        const attachment = this.getFormatData(proposalJson, format.attachId);
        const { previewAttributes } = this.getCredentialLinkedAttachments(indyFormat.attributes, indyFormat.linkedAttachments);
        // Set the metadata
        credentialRecord.metadata.set(CredentialMetadataTypes_1.CredentialMetadataKeys.IndyCredential, {
            schemaId: proposal.schemaId,
            credentialDefinitionId: proposal.credentialDefinitionId,
        });
        return { format, attachment, previewAttributes };
    }
    async processProposal({ attachment }) {
        const credProposalJson = attachment.getDataAsJson();
        if (!credProposalJson) {
            throw new error_1.AriesFrameworkError('Missing indy credential proposal data payload');
        }
        const credProposal = JsonTransformer_1.JsonTransformer.fromJSON(credProposalJson, IndyCredPropose_1.IndyCredPropose);
        MessageValidator_1.MessageValidator.validateSync(credProposal);
    }
    async acceptProposal({ attachId, credentialFormats, credentialRecord, proposalAttachment, }) {
        var _a, _b;
        const indyFormat = credentialFormats === null || credentialFormats === void 0 ? void 0 : credentialFormats.indy;
        const credentialProposal = JsonTransformer_1.JsonTransformer.fromJSON(proposalAttachment.getDataAsJson(), IndyCredPropose_1.IndyCredPropose);
        const credentialDefinitionId = (_a = indyFormat === null || indyFormat === void 0 ? void 0 : indyFormat.credentialDefinitionId) !== null && _a !== void 0 ? _a : credentialProposal.credentialDefinitionId;
        const attributes = (_b = indyFormat === null || indyFormat === void 0 ? void 0 : indyFormat.attributes) !== null && _b !== void 0 ? _b : credentialRecord.credentialAttributes;
        if (!credentialDefinitionId) {
            throw new error_1.AriesFrameworkError('No credentialDefinitionId in proposal or provided as input to accept proposal method.');
        }
        if (!attributes) {
            throw new error_1.AriesFrameworkError('No attributes in proposal or provided as input to accept proposal method.');
        }
        const { format, attachment, previewAttributes } = await this.createIndyOffer({
            credentialRecord,
            attachId,
            attributes,
            credentialDefinitionId: credentialDefinitionId,
            linkedAttachments: indyFormat === null || indyFormat === void 0 ? void 0 : indyFormat.linkedAttachments,
        });
        return { format, attachment, previewAttributes };
    }
    /**
     * Create a {@link AttachmentFormats} object dependent on the message type.
     *
     * @param options The object containing all the options for the credential offer
     * @param messageType the type of message which can be Indy, JsonLd etc eg "CRED_20_OFFER"
     * @returns object containing associated attachment, formats and offersAttach elements
     *
     */
    async createOffer({ credentialFormats, credentialRecord, attachId, }) {
        const indyFormat = credentialFormats.indy;
        if (!indyFormat) {
            throw new error_1.AriesFrameworkError('Missing indy credentialFormat data');
        }
        const { format, attachment, previewAttributes } = await this.createIndyOffer({
            credentialRecord,
            attachId,
            attributes: indyFormat.attributes,
            credentialDefinitionId: indyFormat.credentialDefinitionId,
            linkedAttachments: indyFormat.linkedAttachments,
        });
        return { format, attachment, previewAttributes };
    }
    async processOffer({ attachment, credentialRecord }) {
        this.logger.debug(`Processing indy credential offer for credential record ${credentialRecord.id}`);
        const credOffer = attachment.getDataAsJson();
        if (!credOffer.schema_id || !credOffer.cred_def_id) {
            throw new errors_1.CredentialProblemReportError('Invalid credential offer', {
                problemCode: errors_1.CredentialProblemReportReason.IssuanceAbandoned,
            });
        }
    }
    async acceptOffer({ credentialFormats, credentialRecord, attachId, offerAttachment, }) {
        var _a;
        const indyFormat = credentialFormats === null || credentialFormats === void 0 ? void 0 : credentialFormats.indy;
        const holderDid = (_a = indyFormat === null || indyFormat === void 0 ? void 0 : indyFormat.holderDid) !== null && _a !== void 0 ? _a : (await this.getIndyHolderDid(credentialRecord));
        const credentialOffer = offerAttachment.getDataAsJson();
        const credentialDefinition = await this.indyLedgerService.getCredentialDefinition(credentialOffer.cred_def_id);
        const [credentialRequest, credentialRequestMetadata] = await this.indyHolderService.createCredentialRequest({
            holderDid,
            credentialOffer,
            credentialDefinition,
        });
        credentialRecord.metadata.set(CredentialMetadataTypes_1.CredentialMetadataKeys.IndyRequest, credentialRequestMetadata);
        credentialRecord.metadata.set(CredentialMetadataTypes_1.CredentialMetadataKeys.IndyCredential, {
            credentialDefinitionId: credentialOffer.cred_def_id,
            schemaId: credentialOffer.schema_id,
        });
        const format = new CredentialFormatSpec_1.CredentialFormatSpec({
            attachId,
            format: INDY_CRED_REQUEST,
        });
        const attachment = this.getFormatData(credentialRequest, format.attachId);
        return { format, attachment };
    }
    /**
     * Starting from a request is not supported for indy credentials, this method only throws an error.
     */
    async createRequest() {
        throw new error_1.AriesFrameworkError('Starting from a request is not supported for indy credentials');
    }
    /**
     * We don't have any models to validate an indy request object, for now this method does nothing
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    async processRequest(options) {
        // not needed for Indy
    }
    async acceptRequest({ credentialRecord, attachId, offerAttachment, requestAttachment, }) {
        // Assert credential attributes
        const credentialAttributes = credentialRecord.credentialAttributes;
        if (!credentialAttributes) {
            throw new errors_1.CredentialProblemReportError(`Missing required credential attribute values on credential record with id ${credentialRecord.id}`, { problemCode: errors_1.CredentialProblemReportReason.IssuanceAbandoned });
        }
        const credentialOffer = offerAttachment === null || offerAttachment === void 0 ? void 0 : offerAttachment.getDataAsJson();
        const credentialRequest = requestAttachment.getDataAsJson();
        if (!credentialOffer || !credentialRequest) {
            throw new error_1.AriesFrameworkError('Missing indy credential offer or credential request in createCredential');
        }
        const [credential, credentialRevocationId] = await this.indyIssuerService.createCredential({
            credentialOffer,
            credentialRequest,
            credentialValues: IndyCredentialUtils_1.IndyCredentialUtils.convertAttributesToValues(credentialAttributes),
        });
        if (credential.rev_reg_id) {
            credentialRecord.metadata.add(CredentialMetadataTypes_1.CredentialMetadataKeys.IndyCredential, {
                indyCredentialRevocationId: credentialRevocationId,
                indyRevocationRegistryId: credential.rev_reg_id,
            });
        }
        const format = new CredentialFormatSpec_1.CredentialFormatSpec({
            attachId,
            format: INDY_CRED,
        });
        const attachment = this.getFormatData(credential, format.attachId);
        return { format, attachment };
    }
    /**
     * Processes an incoming credential - retrieve metadata, retrieve payload and store it in the Indy wallet
     * @param options the issue credential message wrapped inside this object
     * @param credentialRecord the credential exchange record for this credential
     */
    async processCredential({ credentialRecord, attachment }) {
        const credentialRequestMetadata = credentialRecord.metadata.get(CredentialMetadataTypes_1.CredentialMetadataKeys.IndyRequest);
        if (!credentialRequestMetadata) {
            throw new errors_1.CredentialProblemReportError(`Missing required request metadata for credential with id ${credentialRecord.id}`, { problemCode: errors_1.CredentialProblemReportReason.IssuanceAbandoned });
        }
        const indyCredential = attachment.getDataAsJson();
        const credentialDefinition = await this.indyLedgerService.getCredentialDefinition(indyCredential.cred_def_id);
        const revocationRegistry = indyCredential.rev_reg_id
            ? await this.indyLedgerService.getRevocationRegistryDefinition(indyCredential.rev_reg_id)
            : null;
        if (!credentialRecord.credentialAttributes) {
            throw new error_1.AriesFrameworkError('Missing credential attributes on credential record. Unable to check credential attributes');
        }
        // assert the credential values match the offer values
        const recordCredentialValues = IndyCredentialUtils_1.IndyCredentialUtils.convertAttributesToValues(credentialRecord.credentialAttributes);
        IndyCredentialUtils_1.IndyCredentialUtils.assertValuesMatch(indyCredential.values, recordCredentialValues);
        const credentialId = await this.indyHolderService.storeCredential({
            credentialId: uuid_1.uuid(),
            credentialRequestMetadata,
            credential: indyCredential,
            credentialDefinition,
            revocationRegistryDefinition: revocationRegistry === null || revocationRegistry === void 0 ? void 0 : revocationRegistry.revocationRegistryDefinition,
        });
        // If the credential is revocable, store the revocation identifiers in the credential record
        if (indyCredential.rev_reg_id) {
            const credential = await this.indyHolderService.getCredential(credentialId);
            credentialRecord.metadata.add(CredentialMetadataTypes_1.CredentialMetadataKeys.IndyCredential, {
                indyCredentialRevocationId: credential.cred_rev_id,
                indyRevocationRegistryId: indyCredential.rev_reg_id,
            });
        }
        credentialRecord.credentials.push({
            credentialRecordType: 'indy',
            credentialRecordId: credentialId,
        });
    }
    supportsFormat(format) {
        const supportedFormats = [INDY_CRED_ABSTRACT, INDY_CRED_REQUEST, INDY_CRED_FILTER, INDY_CRED];
        return supportedFormats.includes(format);
    }
    /**
     * Gets the attachment object for a given attachId. We need to get out the correct attachId for
     * indy and then find the corresponding attachment (if there is one)
     * @param formats the formats object containing the attachId
     * @param messageAttachments the attachments containing the payload
     * @returns The Attachment if found or undefined
     *
     */
    getAttachment(formats, messageAttachments) {
        const supportedAttachmentIds = formats.filter((f) => this.supportsFormat(f.format)).map((f) => f.attachId);
        const supportedAttachments = messageAttachments.filter((attachment) => supportedAttachmentIds.includes(attachment.id));
        return supportedAttachments[0];
    }
    async deleteCredentialById(credentialRecordId) {
        await this.indyHolderService.deleteCredential(credentialRecordId);
    }
    shouldAutoRespondToProposal({ offerAttachment, proposalAttachment }) {
        const credentialProposalJson = proposalAttachment.getDataAsJson();
        const credentialProposal = JsonTransformer_1.JsonTransformer.fromJSON(credentialProposalJson, IndyCredPropose_1.IndyCredPropose);
        const credentialOfferJson = offerAttachment.getDataAsJson();
        // We want to make sure the credential definition matches.
        // TODO: If no credential definition is present on the proposal, we could check whether the other fields
        // of the proposal match with the credential definition id.
        return credentialProposal.credentialDefinitionId === credentialOfferJson.cred_def_id;
    }
    shouldAutoRespondToOffer({ offerAttachment, proposalAttachment }) {
        const credentialProposalJson = proposalAttachment.getDataAsJson();
        const credentialProposal = JsonTransformer_1.JsonTransformer.fromJSON(credentialProposalJson, IndyCredPropose_1.IndyCredPropose);
        const credentialOfferJson = offerAttachment.getDataAsJson();
        // We want to make sure the credential definition matches.
        // TODO: If no credential definition is present on the proposal, we could check whether the other fields
        // of the proposal match with the credential definition id.
        return credentialProposal.credentialDefinitionId === credentialOfferJson.cred_def_id;
    }
    shouldAutoRespondToRequest({ offerAttachment, requestAttachment }) {
        const credentialOfferJson = offerAttachment.getDataAsJson();
        const credentialRequestJson = requestAttachment.getDataAsJson();
        return credentialOfferJson.cred_def_id == credentialRequestJson.cred_def_id;
    }
    shouldAutoRespondToCredential({ credentialRecord, requestAttachment, credentialAttachment, }) {
        const credentialJson = credentialAttachment.getDataAsJson();
        const credentialRequestJson = requestAttachment.getDataAsJson();
        // make sure the credential definition matches
        if (credentialJson.cred_def_id !== credentialRequestJson.cred_def_id)
            return false;
        // If we don't have any attributes stored we can't compare so always return false.
        if (!credentialRecord.credentialAttributes)
            return false;
        const attributeValues = IndyCredentialUtils_1.IndyCredentialUtils.convertAttributesToValues(credentialRecord.credentialAttributes);
        // check whether the values match the values in the record
        return IndyCredentialUtils_1.IndyCredentialUtils.checkValuesMatch(attributeValues, credentialJson.values);
    }
    async createIndyOffer({ credentialRecord, attachId, credentialDefinitionId, attributes, linkedAttachments, }) {
        // if the proposal has an attachment Id use that, otherwise the generated id of the formats object
        const format = new CredentialFormatSpec_1.CredentialFormatSpec({
            attachId: attachId,
            format: INDY_CRED_ABSTRACT,
        });
        const offer = await this.indyIssuerService.createCredentialOffer(credentialDefinitionId);
        const { previewAttributes } = this.getCredentialLinkedAttachments(attributes, linkedAttachments);
        if (!previewAttributes) {
            throw new error_1.AriesFrameworkError('Missing required preview attributes for indy offer');
        }
        await this.assertPreviewAttributesMatchSchemaAttributes(offer, previewAttributes);
        credentialRecord.metadata.set(CredentialMetadataTypes_1.CredentialMetadataKeys.IndyCredential, {
            schemaId: offer.schema_id,
            credentialDefinitionId: offer.cred_def_id,
        });
        const attachment = this.getFormatData(offer, format.attachId);
        return { format, attachment, previewAttributes };
    }
    async assertPreviewAttributesMatchSchemaAttributes(offer, attributes) {
        const schema = await this.indyLedgerService.getSchema(offer.schema_id);
        IndyCredentialUtils_1.IndyCredentialUtils.checkAttributesMatch(schema, attributes);
    }
    async getIndyHolderDid(credentialRecord) {
        // If we have a connection id we try to extract the did from the connection did document.
        if (credentialRecord.connectionId) {
            const connection = await this.connectionService.getById(credentialRecord.connectionId);
            if (!connection.did) {
                throw new error_1.AriesFrameworkError(`Connection record ${connection.id} has no 'did'`);
            }
            const resolved = await this.didResolver.resolve(connection.did);
            if (resolved.didDocument) {
                const verificationMethod = await dids_1.findVerificationMethodByKeyType('Ed25519VerificationKey2018', resolved.didDocument);
                if (verificationMethod) {
                    return did_1.getIndyDidFromVerificationMethod(verificationMethod);
                }
            }
        }
        // If it wasn't successful to extract the did from the connection, we'll create a new key (e.g. if using connection-less)
        // FIXME: we already create a did for the exchange when using connection-less, but this is on a higher level. We should look at
        // a way to reuse this key, but for now this is easier.
        const { did } = await this.wallet.createDid();
        return did;
    }
    /**
     * Get linked attachments for indy format from a proposal message. This allows attachments
     * to be copied across to old style credential records
     *
     * @param options ProposeCredentialOptions object containing (optionally) the linked attachments
     * @return array of linked attachments or undefined if none present
     */
    getCredentialLinkedAttachments(attributes, linkedAttachments) {
        var _a;
        if (!linkedAttachments && !attributes) {
            return {};
        }
        let previewAttributes = (_a = attributes === null || attributes === void 0 ? void 0 : attributes.map((attribute) => new CredentialPreviewAttribute_1.CredentialPreviewAttribute(attribute))) !== null && _a !== void 0 ? _a : [];
        let attachments;
        if (linkedAttachments) {
            // there are linked attachments so transform into the attribute field of the CredentialPreview object for
            // this proposal
            previewAttributes = IndyCredentialUtils_1.IndyCredentialUtils.createAndLinkAttachmentsToPreview(linkedAttachments, previewAttributes);
            attachments = linkedAttachments.map((linkedAttachment) => linkedAttachment.attachment);
        }
        return { attachments, previewAttributes };
    }
};
IndyCredentialFormatService = __decorate([
    plugins_1.injectable(),
    __param(8, plugins_1.inject(constants_1.InjectionSymbols.Wallet)),
    __metadata("design:paramtypes", [CredentialRepository_1.CredentialRepository,
        EventEmitter_1.EventEmitter,
        indy_1.IndyIssuerService,
        ledger_1.IndyLedgerService,
        indy_1.IndyHolderService,
        connections_1.ConnectionService,
        dids_1.DidResolverService,
        AgentConfig_1.AgentConfig, Object])
], IndyCredentialFormatService);
exports.IndyCredentialFormatService = IndyCredentialFormatService;
//# sourceMappingURL=IndyCredentialFormatService.js.map