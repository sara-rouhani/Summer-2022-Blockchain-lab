"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var ConnectionsModule_1;
Object.defineProperty(exports, "__esModule", { value: true });
exports.ConnectionsModule = void 0;
const AgentConfig_1 = require("../../agent/AgentConfig");
const Dispatcher_1 = require("../../agent/Dispatcher");
const MessageSender_1 = require("../../agent/MessageSender");
const helpers_1 = require("../../agent/helpers");
const TransportDecorator_1 = require("../../decorators/transport/TransportDecorator");
const error_1 = require("../../error");
const plugins_1 = require("../../plugins");
const dids_1 = require("../dids");
const repository_1 = require("../dids/repository");
const OutOfBandService_1 = require("../oob/OutOfBandService");
const RoutingService_1 = require("../routing/services/RoutingService");
const DidExchangeProtocol_1 = require("./DidExchangeProtocol");
const handlers_1 = require("./handlers");
const models_1 = require("./models");
const repository_2 = require("./repository");
const ConnectionService_1 = require("./services/ConnectionService");
const TrustPingService_1 = require("./services/TrustPingService");
let ConnectionsModule = ConnectionsModule_1 = class ConnectionsModule {
    constructor(dispatcher, agentConfig, didExchangeProtocol, connectionService, outOfBandService, trustPingService, routingService, didRepository, didResolverService, messageSender) {
        this.agentConfig = agentConfig;
        this.didExchangeProtocol = didExchangeProtocol;
        this.connectionService = connectionService;
        this.outOfBandService = outOfBandService;
        this.trustPingService = trustPingService;
        this.routingService = routingService;
        this.didRepository = didRepository;
        this.messageSender = messageSender;
        this.didResolverService = didResolverService;
        this.registerHandlers(dispatcher);
    }
    async acceptOutOfBandInvitation(outOfBandRecord, config) {
        const { protocol, label, alias, imageUrl, autoAcceptConnection } = config;
        const routing = config.routing || (await this.routingService.getRouting({ mediatorId: outOfBandRecord.mediatorId }));
        let result;
        if (protocol === models_1.HandshakeProtocol.DidExchange) {
            result = await this.didExchangeProtocol.createRequest(outOfBandRecord, {
                label,
                alias,
                routing,
                autoAcceptConnection,
            });
        }
        else if (protocol === models_1.HandshakeProtocol.Connections) {
            result = await this.connectionService.createRequest(outOfBandRecord, {
                label,
                alias,
                imageUrl,
                routing,
                autoAcceptConnection,
            });
        }
        else {
            throw new error_1.AriesFrameworkError(`Unsupported handshake protocol ${protocol}.`);
        }
        const { message, connectionRecord } = result;
        const outboundMessage = helpers_1.createOutboundMessage(connectionRecord, message, outOfBandRecord);
        await this.messageSender.sendMessage(outboundMessage);
        return connectionRecord;
    }
    /**
     * Accept a connection request as inviter (by sending a connection response message) for the connection with the specified connection id.
     * This is not needed when auto accepting of connection is enabled.
     *
     * @param connectionId the id of the connection for which to accept the request
     * @returns connection record
     */
    async acceptRequest(connectionId) {
        const connectionRecord = await this.connectionService.findById(connectionId);
        if (!connectionRecord) {
            throw new error_1.AriesFrameworkError(`Connection record ${connectionId} not found.`);
        }
        if (!connectionRecord.outOfBandId) {
            throw new error_1.AriesFrameworkError(`Connection record ${connectionId} does not have out-of-band record.`);
        }
        const outOfBandRecord = await this.outOfBandService.findById(connectionRecord.outOfBandId);
        if (!outOfBandRecord) {
            throw new error_1.AriesFrameworkError(`Out-of-band record ${connectionRecord.outOfBandId} not found.`);
        }
        let outboundMessage;
        if (connectionRecord.protocol === models_1.HandshakeProtocol.DidExchange) {
            const message = await this.didExchangeProtocol.createResponse(connectionRecord, outOfBandRecord);
            outboundMessage = helpers_1.createOutboundMessage(connectionRecord, message);
        }
        else {
            const { message } = await this.connectionService.createResponse(connectionRecord, outOfBandRecord);
            outboundMessage = helpers_1.createOutboundMessage(connectionRecord, message);
        }
        await this.messageSender.sendMessage(outboundMessage);
        return connectionRecord;
    }
    /**
     * Accept a connection response as invitee (by sending a trust ping message) for the connection with the specified connection id.
     * This is not needed when auto accepting of connection is enabled.
     *
     * @param connectionId the id of the connection for which to accept the response
     * @returns connection record
     */
    async acceptResponse(connectionId) {
        const connectionRecord = await this.connectionService.getById(connectionId);
        let outboundMessage;
        if (connectionRecord.protocol === models_1.HandshakeProtocol.DidExchange) {
            if (!connectionRecord.outOfBandId) {
                throw new error_1.AriesFrameworkError(`Connection ${connectionRecord.id} does not have outOfBandId!`);
            }
            const outOfBandRecord = await this.outOfBandService.findById(connectionRecord.outOfBandId);
            if (!outOfBandRecord) {
                throw new error_1.AriesFrameworkError(`OutOfBand record for connection ${connectionRecord.id} with outOfBandId ${connectionRecord.outOfBandId} not found!`);
            }
            const message = await this.didExchangeProtocol.createComplete(connectionRecord, outOfBandRecord);
            // Disable return routing as we don't want to receive a response for this message over the same channel
            // This has led to long timeouts as not all clients actually close an http socket if there is no response message
            message.setReturnRouting(TransportDecorator_1.ReturnRouteTypes.none);
            outboundMessage = helpers_1.createOutboundMessage(connectionRecord, message);
        }
        else {
            const { message } = await this.connectionService.createTrustPing(connectionRecord, {
                responseRequested: false,
            });
            // Disable return routing as we don't want to receive a response for this message over the same channel
            // This has led to long timeouts as not all clients actually close an http socket if there is no response message
            message.setReturnRouting(TransportDecorator_1.ReturnRouteTypes.none);
            outboundMessage = helpers_1.createOutboundMessage(connectionRecord, message);
        }
        await this.messageSender.sendMessage(outboundMessage);
        return connectionRecord;
    }
    async returnWhenIsConnected(connectionId, options) {
        return this.connectionService.returnWhenIsConnected(connectionId, options === null || options === void 0 ? void 0 : options.timeoutMs);
    }
    /**
     * Retrieve all connections records
     *
     * @returns List containing all connection records
     */
    getAll() {
        return this.connectionService.getAll();
    }
    /**
     * Retrieve a connection record by id
     *
     * @param connectionId The connection record id
     * @throws {RecordNotFoundError} If no record is found
     * @return The connection record
     *
     */
    getById(connectionId) {
        return this.connectionService.getById(connectionId);
    }
    /**
     * Find a connection record by id
     *
     * @param connectionId the connection record id
     * @returns The connection record or null if not found
     */
    findById(connectionId) {
        return this.connectionService.findById(connectionId);
    }
    /**
     * Delete a connection record by id
     *
     * @param connectionId the connection record id
     */
    async deleteById(connectionId) {
        return this.connectionService.deleteById(connectionId);
    }
    async findByKeys({ senderKey, recipientKey }) {
        const theirDidRecord = await this.didRepository.findByRecipientKey(senderKey);
        if (theirDidRecord) {
            const ourDidRecord = await this.didRepository.findByRecipientKey(recipientKey);
            if (ourDidRecord) {
                const connectionRecord = await this.connectionService.findSingleByQuery({
                    did: ourDidRecord.id,
                    theirDid: theirDidRecord.id,
                });
                if (connectionRecord && connectionRecord.isReady)
                    return connectionRecord;
            }
        }
        this.agentConfig.logger.debug(`No connection record found for encrypted message with recipient key ${recipientKey.fingerprint} and sender key ${senderKey.fingerprint}`);
        return null;
    }
    async findAllByOutOfBandId(outOfBandId) {
        return this.connectionService.findAllByOutOfBandId(outOfBandId);
    }
    /**
     * Retrieve a connection record by thread id
     *
     * @param threadId The thread id
     * @throws {RecordNotFoundError} If no record is found
     * @throws {RecordDuplicateError} If multiple records are found
     * @returns The connection record
     */
    getByThreadId(threadId) {
        return this.connectionService.getByThreadId(threadId);
    }
    async findByDid(did) {
        return this.connectionService.findByTheirDid(did);
    }
    async findByInvitationDid(invitationDid) {
        return this.connectionService.findByInvitationDid(invitationDid);
    }
    registerHandlers(dispatcher) {
        dispatcher.registerHandler(new handlers_1.ConnectionRequestHandler(this.agentConfig, this.connectionService, this.outOfBandService, this.routingService, this.didRepository));
        dispatcher.registerHandler(new handlers_1.ConnectionResponseHandler(this.agentConfig, this.connectionService, this.outOfBandService, this.didResolverService));
        dispatcher.registerHandler(new handlers_1.AckMessageHandler(this.connectionService));
        dispatcher.registerHandler(new handlers_1.TrustPingMessageHandler(this.trustPingService, this.connectionService));
        dispatcher.registerHandler(new handlers_1.TrustPingResponseMessageHandler(this.trustPingService));
        dispatcher.registerHandler(new handlers_1.DidExchangeRequestHandler(this.agentConfig, this.didExchangeProtocol, this.outOfBandService, this.routingService, this.didRepository));
        dispatcher.registerHandler(new handlers_1.DidExchangeResponseHandler(this.agentConfig, this.didExchangeProtocol, this.outOfBandService, this.connectionService, this.didResolverService));
        dispatcher.registerHandler(new handlers_1.DidExchangeCompleteHandler(this.didExchangeProtocol, this.outOfBandService));
    }
    /**
     * Registers the dependencies of the connections module on the dependency manager.
     */
    static register(dependencyManager) {
        // Api
        dependencyManager.registerContextScoped(ConnectionsModule_1);
        // Services
        dependencyManager.registerSingleton(ConnectionService_1.ConnectionService);
        dependencyManager.registerSingleton(DidExchangeProtocol_1.DidExchangeProtocol);
        dependencyManager.registerSingleton(TrustPingService_1.TrustPingService);
        // Repositories
        dependencyManager.registerSingleton(repository_2.ConnectionRepository);
    }
};
ConnectionsModule = ConnectionsModule_1 = __decorate([
    plugins_1.module(),
    plugins_1.injectable(),
    __metadata("design:paramtypes", [Dispatcher_1.Dispatcher,
        AgentConfig_1.AgentConfig,
        DidExchangeProtocol_1.DidExchangeProtocol,
        ConnectionService_1.ConnectionService,
        OutOfBandService_1.OutOfBandService,
        TrustPingService_1.TrustPingService,
        RoutingService_1.RoutingService,
        repository_1.DidRepository,
        dids_1.DidResolverService,
        MessageSender_1.MessageSender])
], ConnectionsModule);
exports.ConnectionsModule = ConnectionsModule;
//# sourceMappingURL=ConnectionsModule.js.map