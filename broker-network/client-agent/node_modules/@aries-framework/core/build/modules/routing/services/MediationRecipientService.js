"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.MediationRecipientService = void 0;
const rxjs_1 = require("rxjs");
const operators_1 = require("rxjs/operators");
const AgentConfig_1 = require("../../../agent/AgentConfig");
const EventEmitter_1 = require("../../../agent/EventEmitter");
const Events_1 = require("../../../agent/Events");
const MessageSender_1 = require("../../../agent/MessageSender");
const helpers_1 = require("../../../agent/helpers");
const crypto_1 = require("../../../crypto");
const error_1 = require("../../../error");
const plugins_1 = require("../../../plugins");
const utils_1 = require("../../../utils");
const ConnectionService_1 = require("../../connections/services/ConnectionService");
const dids_1 = require("../../dids");
const helpers_2 = require("../../dids/helpers");
const problem_reports_1 = require("../../problem-reports");
const RoutingEvents_1 = require("../RoutingEvents");
const error_2 = require("../error");
const messages_1 = require("../messages");
const KeylistUpdateMessage_1 = require("../messages/KeylistUpdateMessage");
const models_1 = require("../models");
const MediationRecord_1 = require("../repository/MediationRecord");
const MediationRepository_1 = require("../repository/MediationRepository");
let MediationRecipientService = class MediationRecipientService {
    constructor(connectionService, messageSender, config, mediatorRepository, eventEmitter) {
        this.config = config;
        this.mediationRepository = mediatorRepository;
        this.eventEmitter = eventEmitter;
        this.connectionService = connectionService;
        this.messageSender = messageSender;
    }
    async createStatusRequest(mediationRecord, config = {}) {
        mediationRecord.assertRole(models_1.MediationRole.Recipient);
        mediationRecord.assertReady();
        const { recipientKey } = config;
        const statusRequest = new messages_1.StatusRequestMessage({
            recipientKey,
        });
        return statusRequest;
    }
    async createRequest(connection) {
        const message = new messages_1.MediationRequestMessage({});
        const mediationRecord = new MediationRecord_1.MediationRecord({
            threadId: message.threadId,
            state: models_1.MediationState.Requested,
            role: models_1.MediationRole.Recipient,
            connectionId: connection.id,
        });
        await this.mediationRepository.save(mediationRecord);
        this.emitStateChangedEvent(mediationRecord, null);
        return { mediationRecord, message };
    }
    async processMediationGrant(messageContext) {
        // Assert ready connection
        const connection = messageContext.assertReadyConnection();
        // Mediation record must already exists to be updated to granted status
        const mediationRecord = await this.mediationRepository.getByConnectionId(connection.id);
        // Assert
        mediationRecord.assertState(models_1.MediationState.Requested);
        mediationRecord.assertRole(models_1.MediationRole.Recipient);
        // Update record
        mediationRecord.endpoint = messageContext.message.endpoint;
        // According to RFC 0211 keys should be a did key, but base58 encoded verkey was used before
        // RFC was accepted. This converts the key to a public key base58 if it is a did key.
        mediationRecord.routingKeys = messageContext.message.routingKeys.map(helpers_2.didKeyToVerkey);
        return await this.updateState(mediationRecord, models_1.MediationState.Granted);
    }
    async processKeylistUpdateResults(messageContext) {
        // Assert ready connection
        const connection = messageContext.assertReadyConnection();
        const mediationRecord = await this.mediationRepository.getByConnectionId(connection.id);
        // Assert
        mediationRecord.assertReady();
        mediationRecord.assertRole(models_1.MediationRole.Recipient);
        const keylist = messageContext.message.updated;
        // update keylist in mediationRecord
        for (const update of keylist) {
            if (update.action === messages_1.KeylistUpdateAction.add) {
                mediationRecord.addRecipientKey(update.recipientKey);
            }
            else if (update.action === messages_1.KeylistUpdateAction.remove) {
                mediationRecord.removeRecipientKey(update.recipientKey);
            }
        }
        await this.mediationRepository.update(mediationRecord);
        this.eventEmitter.emit({
            type: RoutingEvents_1.RoutingEventTypes.RecipientKeylistUpdated,
            payload: {
                mediationRecord,
                keylist,
            },
        });
    }
    async keylistUpdateAndAwait(mediationRecord, verKey, timeoutMs = 15000 // TODO: this should be a configurable value in agent config
    ) {
        const message = this.createKeylistUpdateMessage(verKey);
        const connection = await this.connectionService.getById(mediationRecord.connectionId);
        mediationRecord.assertReady();
        mediationRecord.assertRole(models_1.MediationRole.Recipient);
        // Create observable for event
        const observable = this.eventEmitter.observable(RoutingEvents_1.RoutingEventTypes.RecipientKeylistUpdated);
        const subject = new rxjs_1.ReplaySubject(1);
        // Apply required filters to observable stream and create promise to subscribe to observable
        observable
            .pipe(
        // Only take event for current mediation record
        operators_1.filter((event) => mediationRecord.id === event.payload.mediationRecord.id), 
        // Only wait for first event that matches the criteria
        operators_1.first(), 
        // Do not wait for longer than specified timeout
        operators_1.timeout(timeoutMs))
            .subscribe(subject);
        const outboundMessage = helpers_1.createOutboundMessage(connection, message);
        await this.messageSender.sendMessage(outboundMessage);
        const keylistUpdate = await rxjs_1.firstValueFrom(subject);
        return keylistUpdate.payload.mediationRecord;
    }
    createKeylistUpdateMessage(verkey) {
        const keylistUpdateMessage = new KeylistUpdateMessage_1.KeylistUpdateMessage({
            updates: [
                new KeylistUpdateMessage_1.KeylistUpdate({
                    action: messages_1.KeylistUpdateAction.add,
                    recipientKey: verkey,
                }),
            ],
        });
        return keylistUpdateMessage;
    }
    async addMediationRouting(routing, { mediatorId, useDefaultMediator = true } = {}) {
        let mediationRecord = null;
        if (mediatorId) {
            mediationRecord = await this.getById(mediatorId);
        }
        else if (useDefaultMediator) {
            // If no mediatorId is provided, and useDefaultMediator is true (default)
            // We use the default mediator if available
            mediationRecord = await this.findDefaultMediator();
        }
        // Return early if no mediation record
        if (!mediationRecord)
            return routing;
        // new did has been created and mediator needs to be updated with the public key.
        mediationRecord = await this.keylistUpdateAndAwait(mediationRecord, routing.recipientKey.publicKeyBase58);
        return Object.assign(Object.assign({}, routing), { endpoints: mediationRecord.endpoint ? [mediationRecord.endpoint] : routing.endpoints, routingKeys: mediationRecord.routingKeys.map((key) => dids_1.Key.fromPublicKeyBase58(key, crypto_1.KeyType.Ed25519)) });
    }
    async processMediationDeny(messageContext) {
        const connection = messageContext.assertReadyConnection();
        // Mediation record already exists
        const mediationRecord = await this.findByConnectionId(connection.id);
        if (!mediationRecord) {
            throw new Error(`No mediation has been requested for this connection id: ${connection.id}`);
        }
        // Assert
        mediationRecord.assertRole(models_1.MediationRole.Recipient);
        mediationRecord.assertState(models_1.MediationState.Requested);
        // Update record
        await this.updateState(mediationRecord, models_1.MediationState.Denied);
        return mediationRecord;
    }
    async processStatus(messageContext) {
        const connection = messageContext.assertReadyConnection();
        const { message: statusMessage } = messageContext;
        const { messageCount, recipientKey } = statusMessage;
        const mediationRecord = await this.mediationRepository.getByConnectionId(connection.id);
        mediationRecord.assertReady();
        mediationRecord.assertRole(models_1.MediationRole.Recipient);
        //No messages to be sent
        if (messageCount === 0) {
            const { message, connectionRecord } = await this.connectionService.createTrustPing(connection, {
                responseRequested: false,
            });
            const websocketSchemes = ['ws', 'wss'];
            await this.messageSender.sendMessage(helpers_1.createOutboundMessage(connectionRecord, message), {
                transportPriority: {
                    schemes: websocketSchemes,
                    restrictive: true,
                    // TODO: add keepAlive: true to enforce through the public api
                    // we need to keep the socket alive. It already works this way, but would
                    // be good to make more explicit from the public facing API.
                    // This would also make it easier to change the internal API later on.
                    // keepAlive: true,
                },
            });
            return null;
        }
        const { maximumMessagePickup } = this.config;
        const limit = messageCount < maximumMessagePickup ? messageCount : maximumMessagePickup;
        const deliveryRequestMessage = new messages_1.DeliveryRequestMessage({
            limit,
            recipientKey,
        });
        return deliveryRequestMessage;
    }
    async processDelivery(messageContext) {
        const connection = messageContext.assertReadyConnection();
        const { appendedAttachments } = messageContext.message;
        const mediationRecord = await this.mediationRepository.getByConnectionId(connection.id);
        mediationRecord.assertReady();
        mediationRecord.assertRole(models_1.MediationRole.Recipient);
        if (!appendedAttachments)
            throw new problem_reports_1.ProblemReportError('Error processing attachments', {
                problemCode: error_2.RoutingProblemReportReason.ErrorProcessingAttachments,
            });
        const ids = [];
        for (const attachment of appendedAttachments) {
            ids.push(attachment.id);
            this.eventEmitter.emit({
                type: Events_1.AgentEventTypes.AgentMessageReceived,
                payload: {
                    message: attachment.getDataAsJson(),
                },
            });
        }
        return new messages_1.MessagesReceivedMessage({
            messageIdList: ids,
        });
    }
    /**
     * Update the record to a new state and emit an state changed event. Also updates the record
     * in storage.
     *
     * @param MediationRecord The proof record to update the state for
     * @param newState The state to update to
     *
     */
    async updateState(mediationRecord, newState) {
        const previousState = mediationRecord.state;
        mediationRecord.state = newState;
        await this.mediationRepository.update(mediationRecord);
        this.emitStateChangedEvent(mediationRecord, previousState);
        return mediationRecord;
    }
    emitStateChangedEvent(mediationRecord, previousState) {
        const clonedMediationRecord = utils_1.JsonTransformer.clone(mediationRecord);
        this.eventEmitter.emit({
            type: RoutingEvents_1.RoutingEventTypes.MediationStateChanged,
            payload: {
                mediationRecord: clonedMediationRecord,
                previousState,
            },
        });
    }
    async getById(id) {
        return this.mediationRepository.getById(id);
    }
    async findByConnectionId(connectionId) {
        return this.mediationRepository.findSingleByQuery({ connectionId });
    }
    async getMediators() {
        return this.mediationRepository.getAll();
    }
    async findDefaultMediator() {
        return this.mediationRepository.findSingleByQuery({ default: true });
    }
    async discoverMediation(mediatorId) {
        // If mediatorId is passed, always use it (and error if it is not found)
        if (mediatorId) {
            return this.mediationRepository.getById(mediatorId);
        }
        const defaultMediator = await this.findDefaultMediator();
        if (defaultMediator) {
            if (defaultMediator.state !== models_1.MediationState.Granted) {
                throw new error_1.AriesFrameworkError(`Mediation State for ${defaultMediator.id} is not granted, but is set as default mediator!`);
            }
            return defaultMediator;
        }
    }
    async setDefaultMediator(mediator) {
        const mediationRecords = await this.mediationRepository.findByQuery({ default: true });
        for (const record of mediationRecords) {
            record.setTag('default', false);
            await this.mediationRepository.update(record);
        }
        // Set record coming in tag to true and then update.
        mediator.setTag('default', true);
        await this.mediationRepository.update(mediator);
    }
    async clearDefaultMediator() {
        const mediationRecord = await this.findDefaultMediator();
        if (mediationRecord) {
            mediationRecord.setTag('default', false);
            await this.mediationRepository.update(mediationRecord);
        }
    }
};
MediationRecipientService = __decorate([
    plugins_1.injectable(),
    __metadata("design:paramtypes", [ConnectionService_1.ConnectionService,
        MessageSender_1.MessageSender,
        AgentConfig_1.AgentConfig,
        MediationRepository_1.MediationRepository,
        EventEmitter_1.EventEmitter])
], MediationRecipientService);
exports.MediationRecipientService = MediationRecipientService;
//# sourceMappingURL=MediationRecipientService.js.map