"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.IndyWallet = void 0;
const tsyringe_1 = require("tsyringe");
const AgentConfig_1 = require("../agent/AgentConfig");
const error_1 = require("../error");
const JsonEncoder_1 = require("../utils/JsonEncoder");
const indyError_1 = require("../utils/indyError");
const error_2 = require("./error");
const WalletInvalidKeyError_1 = require("./error/WalletInvalidKeyError");
let IndyWallet = class IndyWallet {
    constructor(agentConfig) {
        this.logger = agentConfig.logger;
        this.indy = agentConfig.agentDependencies.indy;
    }
    get isProvisioned() {
        return this.walletConfig !== undefined;
    }
    get isInitialized() {
        return this.walletHandle !== undefined;
    }
    get publicDid() {
        return this.publicDidInfo;
    }
    get handle() {
        if (!this.walletHandle) {
            throw new error_1.AriesFrameworkError('Wallet has not been initialized yet. Make sure to await agent.initialize() before using the agent.');
        }
        return this.walletHandle;
    }
    get masterSecretId() {
        var _a;
        if (!this.isInitialized || !((_a = this.walletConfig) === null || _a === void 0 ? void 0 : _a.id)) {
            throw new error_1.AriesFrameworkError('Wallet has not been initialized yet. Make sure to await agent.initialize() before using the agent.');
        }
        return this.walletConfig.id;
    }
    walletStorageConfig(walletConfig) {
        var _a, _b, _c;
        const walletStorageConfig = {
            id: walletConfig.id,
            storage_type: (_a = walletConfig.storage) === null || _a === void 0 ? void 0 : _a.type,
        };
        if ((_b = walletConfig.storage) === null || _b === void 0 ? void 0 : _b.config) {
            walletStorageConfig.storage_config = (_c = walletConfig.storage) === null || _c === void 0 ? void 0 : _c.config;
        }
        return walletStorageConfig;
    }
    walletCredentials(walletConfig, rekey, rekeyDerivation) {
        var _a, _b;
        const walletCredentials = {
            key: walletConfig.key,
            key_derivation_method: walletConfig.keyDerivationMethod,
        };
        if (rekey) {
            walletCredentials.rekey = rekey;
        }
        if (rekeyDerivation) {
            walletCredentials.rekey_derivation_method = rekeyDerivation;
        }
        if ((_a = walletConfig.storage) === null || _a === void 0 ? void 0 : _a.credentials) {
            walletCredentials.storage_credentials = (_b = walletConfig.storage) === null || _b === void 0 ? void 0 : _b.credentials;
        }
        return walletCredentials;
    }
    /**
     * @throws {WalletDuplicateError} if the wallet already exists
     * @throws {WalletError} if another error occurs
     */
    async create(walletConfig) {
        await this.createAndOpen(walletConfig);
        await this.close();
    }
    /**
     * @throws {WalletDuplicateError} if the wallet already exists
     * @throws {WalletError} if another error occurs
     */
    async createAndOpen(walletConfig) {
        this.logger.debug(`Creating wallet '${walletConfig.id}' using SQLite storage`);
        try {
            await this.indy.createWallet(this.walletStorageConfig(walletConfig), this.walletCredentials(walletConfig));
            this.walletConfig = walletConfig;
            // We usually want to create master secret only once, therefore, we can to do so when creating a wallet.
            await this.open(walletConfig);
            // We need to open wallet before creating master secret because we need wallet handle here.
            await this.createMasterSecret(this.handle, walletConfig.id);
        }
        catch (error) {
            // If an error ocurred while creating the master secret, we should close the wallet
            if (this.isInitialized)
                await this.close();
            if (indyError_1.isIndyError(error, 'WalletAlreadyExistsError')) {
                const errorMessage = `Wallet '${walletConfig.id}' already exists`;
                this.logger.debug(errorMessage);
                throw new error_2.WalletDuplicateError(errorMessage, {
                    walletType: 'IndyWallet',
                    cause: error,
                });
            }
            else {
                const errorMessage = `Error creating wallet '${walletConfig.id}'`;
                this.logger.error(errorMessage, {
                    error,
                    errorMessage: error.message,
                });
                throw new error_2.WalletError(errorMessage, { cause: error });
            }
        }
        this.logger.debug(`Successfully created wallet '${walletConfig.id}'`);
    }
    /**
     * @throws {WalletNotFoundError} if the wallet does not exist
     * @throws {WalletError} if another error occurs
     */
    async open(walletConfig) {
        await this._open(walletConfig);
    }
    /**
     * @throws {WalletNotFoundError} if the wallet does not exist
     * @throws {WalletError} if another error occurs
     */
    async rotateKey(walletConfig) {
        if (!walletConfig.rekey) {
            throw new error_2.WalletError('Wallet rekey undefined!. Please specify the new wallet key');
        }
        await this._open({
            id: walletConfig.id,
            key: walletConfig.key,
            keyDerivationMethod: walletConfig.keyDerivationMethod,
        }, walletConfig.rekey, walletConfig.rekeyDerivationMethod);
    }
    /**
     * @throws {WalletNotFoundError} if the wallet does not exist
     * @throws {WalletError} if another error occurs
     */
    async _open(walletConfig, rekey, rekeyDerivation) {
        if (this.walletHandle) {
            throw new error_2.WalletError('Wallet instance already opened. Close the currently opened wallet before re-opening the wallet');
        }
        try {
            this.walletHandle = await this.indy.openWallet(this.walletStorageConfig(walletConfig), this.walletCredentials(walletConfig, rekey, rekeyDerivation));
            if (rekey) {
                this.walletConfig = Object.assign(Object.assign({}, walletConfig), { key: rekey, keyDerivationMethod: rekeyDerivation });
            }
            else {
                this.walletConfig = walletConfig;
            }
        }
        catch (error) {
            if (indyError_1.isIndyError(error, 'WalletNotFoundError')) {
                const errorMessage = `Wallet '${walletConfig.id}' not found`;
                this.logger.debug(errorMessage);
                throw new error_2.WalletNotFoundError(errorMessage, {
                    walletType: 'IndyWallet',
                    cause: error,
                });
            }
            else if (indyError_1.isIndyError(error, 'WalletAccessFailed')) {
                const errorMessage = `Incorrect key for wallet '${walletConfig.id}'`;
                this.logger.debug(errorMessage);
                throw new WalletInvalidKeyError_1.WalletInvalidKeyError(errorMessage, {
                    walletType: 'IndyWallet',
                    cause: error,
                });
            }
            else {
                const errorMessage = `Error opening wallet '${walletConfig.id}': ${error.message}`;
                this.logger.error(errorMessage, {
                    error,
                    errorMessage: error.message,
                });
                throw new error_2.WalletError(errorMessage, { cause: error });
            }
        }
        this.logger.debug(`Wallet '${walletConfig.id}' opened with handle '${this.handle}'`);
    }
    /**
     * @throws {WalletNotFoundError} if the wallet does not exist
     * @throws {WalletError} if another error occurs
     */
    async delete() {
        if (!this.walletConfig) {
            throw new error_2.WalletError('Can not delete wallet that does not have wallet config set. Make sure to call create wallet before deleting the wallet');
        }
        this.logger.info(`Deleting wallet '${this.walletConfig.id}'`);
        if (this.walletHandle) {
            await this.close();
        }
        try {
            await this.indy.deleteWallet(this.walletStorageConfig(this.walletConfig), this.walletCredentials(this.walletConfig));
        }
        catch (error) {
            if (indyError_1.isIndyError(error, 'WalletNotFoundError')) {
                const errorMessage = `Error deleting wallet: wallet '${this.walletConfig.id}' not found`;
                this.logger.debug(errorMessage);
                throw new error_2.WalletNotFoundError(errorMessage, {
                    walletType: 'IndyWallet',
                    cause: error,
                });
            }
            else {
                const errorMessage = `Error deleting wallet '${this.walletConfig.id}': ${error.message}`;
                this.logger.error(errorMessage, {
                    error,
                    errorMessage: error.message,
                });
                throw new error_2.WalletError(errorMessage, { cause: error });
            }
        }
    }
    async export(exportConfig) {
        var _a;
        try {
            this.logger.debug(`Exporting wallet ${(_a = this.walletConfig) === null || _a === void 0 ? void 0 : _a.id} to path ${exportConfig.path}`);
            await this.indy.exportWallet(this.handle, exportConfig);
        }
        catch (error) {
            const errorMessage = `Error exporting wallet: ${error.message}`;
            this.logger.error(errorMessage, {
                error,
            });
            throw new error_2.WalletError(errorMessage, { cause: error });
        }
    }
    async import(walletConfig, importConfig) {
        try {
            this.logger.debug(`Importing wallet ${walletConfig.id} from path ${importConfig.path}`);
            await this.indy.importWallet({ id: walletConfig.id }, { key: walletConfig.key, key_derivation_method: walletConfig.keyDerivationMethod }, importConfig);
        }
        catch (error) {
            const errorMessage = `Error importing wallet': ${error.message}`;
            this.logger.error(errorMessage, {
                error,
            });
            throw new error_2.WalletError(errorMessage, { cause: error });
        }
    }
    /**
     * @throws {WalletError} if the wallet is already closed or another error occurs
     */
    async close() {
        if (!this.walletHandle) {
            throw new error_2.WalletError('Wallet is in invalid state, you are trying to close wallet that has no `walletHandle`.');
        }
        try {
            await this.indy.closeWallet(this.walletHandle);
            this.walletHandle = undefined;
            this.publicDidInfo = undefined;
        }
        catch (error) {
            if (indyError_1.isIndyError(error, 'WalletInvalidHandle')) {
                const errorMessage = `Error closing wallet: wallet already closed`;
                this.logger.debug(errorMessage);
                throw new error_2.WalletError(errorMessage, {
                    cause: error,
                });
            }
            else {
                const errorMessage = `Error closing wallet': ${error.message}`;
                this.logger.error(errorMessage, {
                    error,
                    errorMessage: error.message,
                });
                throw new error_2.WalletError(errorMessage, { cause: error });
            }
        }
    }
    /**
     * Create master secret with specified id in currently opened wallet.
     *
     * If a master secret by this id already exists in the current wallet, the method
     * will return without doing anything.
     *
     * @throws {WalletError} if an error occurs
     */
    async createMasterSecret(walletHandle, masterSecretId) {
        this.logger.debug(`Creating master secret with id '${masterSecretId}' in wallet with handle '${walletHandle}'`);
        try {
            await this.indy.proverCreateMasterSecret(walletHandle, masterSecretId);
            return masterSecretId;
        }
        catch (error) {
            if (indyError_1.isIndyError(error, 'AnoncredsMasterSecretDuplicateNameError')) {
                // master secret id is the same as the master secret id passed in the create function
                // so if it already exists we can just assign it.
                this.logger.debug(`Master secret with id '${masterSecretId}' already exists in wallet with handle '${walletHandle}'`, {
                    indyError: 'AnoncredsMasterSecretDuplicateNameError',
                });
                return masterSecretId;
            }
            else {
                this.logger.error(`Error creating master secret with id ${masterSecretId}`, {
                    indyError: error.indyName,
                    error,
                });
                throw new error_2.WalletError(`Error creating master secret with id ${masterSecretId} in wallet with handle '${walletHandle}'`, { cause: error });
            }
        }
    }
    async initPublicDid(didConfig) {
        const { did, verkey } = await this.createDid(didConfig);
        this.publicDidInfo = {
            did,
            verkey,
        };
    }
    async createDid(didConfig) {
        try {
            const [did, verkey] = await this.indy.createAndStoreMyDid(this.handle, didConfig || {});
            return { did, verkey };
        }
        catch (error) {
            throw new error_2.WalletError('Error creating Did', { cause: error });
        }
    }
    async pack(payload, recipientKeys, senderVerkey) {
        try {
            const messageRaw = JsonEncoder_1.JsonEncoder.toBuffer(payload);
            const packedMessage = await this.indy.packMessage(this.handle, messageRaw, recipientKeys, senderVerkey !== null && senderVerkey !== void 0 ? senderVerkey : null);
            return JsonEncoder_1.JsonEncoder.fromBuffer(packedMessage);
        }
        catch (error) {
            throw new error_2.WalletError('Error packing message', { cause: error });
        }
    }
    async unpack(messagePackage) {
        try {
            const unpackedMessageBuffer = await this.indy.unpackMessage(this.handle, JsonEncoder_1.JsonEncoder.toBuffer(messagePackage));
            const unpackedMessage = JsonEncoder_1.JsonEncoder.fromBuffer(unpackedMessageBuffer);
            return {
                senderKey: unpackedMessage.sender_verkey,
                recipientKey: unpackedMessage.recipient_verkey,
                plaintextMessage: JsonEncoder_1.JsonEncoder.fromString(unpackedMessage.message),
            };
        }
        catch (error) {
            throw new error_2.WalletError('Error unpacking message', { cause: error });
        }
    }
    async sign(data, verkey) {
        try {
            return await this.indy.cryptoSign(this.handle, verkey, data);
        }
        catch (error) {
            throw new error_2.WalletError(`Error signing data with verkey ${verkey}`, { cause: error });
        }
    }
    async verify(signerVerkey, data, signature) {
        try {
            // check signature
            const isValid = await this.indy.cryptoVerify(signerVerkey, data, signature);
            return isValid;
        }
        catch (error) {
            throw new error_2.WalletError(`Error verifying signature of data signed with verkey ${signerVerkey}`, { cause: error });
        }
    }
    async generateNonce() {
        try {
            return await this.indy.generateNonce();
        }
        catch (error) {
            throw new error_2.WalletError('Error generating nonce', { cause: error });
        }
    }
};
IndyWallet = __decorate([
    tsyringe_1.scoped(tsyringe_1.Lifecycle.ContainerScoped),
    __metadata("design:paramtypes", [AgentConfig_1.AgentConfig])
], IndyWallet);
exports.IndyWallet = IndyWallet;
//# sourceMappingURL=IndyWallet.js.map