"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Agent = void 0;
const operators_1 = require("rxjs/operators");
const tsyringe_1 = require("tsyringe");
const constants_1 = require("../constants");
const error_1 = require("../error");
const BasicMessagesModule_1 = require("../modules/basic-messages/BasicMessagesModule");
const ConnectionsModule_1 = require("../modules/connections/ConnectionsModule");
const CredentialsModule_1 = require("../modules/credentials/CredentialsModule");
const DidsModule_1 = require("../modules/dids/DidsModule");
const discover_features_1 = require("../modules/discover-features");
const GenericRecordsModule_1 = require("../modules/generic-records/GenericRecordsModule");
const LedgerModule_1 = require("../modules/ledger/LedgerModule");
const OutOfBandModule_1 = require("../modules/oob/OutOfBandModule");
const ProofsModule_1 = require("../modules/proofs/ProofsModule");
const QuestionAnswerModule_1 = require("../modules/question-answer/QuestionAnswerModule");
const MediatorModule_1 = require("../modules/routing/MediatorModule");
const RecipientModule_1 = require("../modules/routing/RecipientModule");
const storage_1 = require("../storage");
const InMemoryMessageRepository_1 = require("../storage/InMemoryMessageRepository");
const IndyStorageService_1 = require("../storage/IndyStorageService");
const UpdateAssistant_1 = require("../storage/migration/UpdateAssistant");
const updates_1 = require("../storage/migration/updates");
const IndyWallet_1 = require("../wallet/IndyWallet");
const WalletModule_1 = require("../wallet/WalletModule");
const error_2 = require("../wallet/error");
const AgentConfig_1 = require("./AgentConfig");
const EventEmitter_1 = require("./EventEmitter");
const Events_1 = require("./Events");
const MessageReceiver_1 = require("./MessageReceiver");
const MessageSender_1 = require("./MessageSender");
const TransportService_1 = require("./TransportService");
class Agent {
    constructor(initialConfig, dependencies, injectionContainer) {
        this._isInitialized = false;
        // Take input container or child container so we don't interfere with anything outside of this agent
        this.container = injectionContainer !== null && injectionContainer !== void 0 ? injectionContainer : tsyringe_1.container.createChildContainer();
        this.agentConfig = new AgentConfig_1.AgentConfig(initialConfig, dependencies);
        this.logger = this.agentConfig.logger;
        // Bind class based instances
        this.container.registerInstance(AgentConfig_1.AgentConfig, this.agentConfig);
        // Based on interfaces. Need to register which class to use
        if (!this.container.isRegistered(constants_1.InjectionSymbols.Wallet)) {
            this.container.register(constants_1.InjectionSymbols.Wallet, { useToken: IndyWallet_1.IndyWallet });
        }
        if (!this.container.isRegistered(constants_1.InjectionSymbols.Logger)) {
            this.container.registerInstance(constants_1.InjectionSymbols.Logger, this.logger);
        }
        if (!this.container.isRegistered(constants_1.InjectionSymbols.StorageService)) {
            this.container.registerSingleton(constants_1.InjectionSymbols.StorageService, IndyStorageService_1.IndyStorageService);
        }
        if (!this.container.isRegistered(constants_1.InjectionSymbols.MessageRepository)) {
            this.container.registerSingleton(constants_1.InjectionSymbols.MessageRepository, InMemoryMessageRepository_1.InMemoryMessageRepository);
        }
        this.logger.info('Creating agent with config', Object.assign(Object.assign({}, initialConfig), { 
            // Prevent large object being logged.
            // Will display true/false to indicate if value is present in config
            logger: initialConfig.logger != undefined }));
        if (!this.agentConfig.walletConfig) {
            this.logger.warn('Wallet config has not been set on the agent config. ' +
                'Make sure to initialize the wallet yourself before initializing the agent, ' +
                'or provide the required wallet configuration in the agent constructor');
        }
        // Resolve instances after everything is registered
        this.eventEmitter = this.container.resolve(EventEmitter_1.EventEmitter);
        this.messageSender = this.container.resolve(MessageSender_1.MessageSender);
        this.messageReceiver = this.container.resolve(MessageReceiver_1.MessageReceiver);
        this.transportService = this.container.resolve(TransportService_1.TransportService);
        this.walletService = this.container.resolve(constants_1.InjectionSymbols.Wallet);
        // We set the modules in the constructor because that allows to set them as read-only
        this.connections = this.container.resolve(ConnectionsModule_1.ConnectionsModule);
        this.credentials = this.container.resolve(CredentialsModule_1.CredentialsModule);
        this.proofs = this.container.resolve(ProofsModule_1.ProofsModule);
        this.mediator = this.container.resolve(MediatorModule_1.MediatorModule);
        this.mediationRecipient = this.container.resolve(RecipientModule_1.RecipientModule);
        this.basicMessages = this.container.resolve(BasicMessagesModule_1.BasicMessagesModule);
        this.questionAnswer = this.container.resolve(QuestionAnswerModule_1.QuestionAnswerModule);
        this.genericRecords = this.container.resolve(GenericRecordsModule_1.GenericRecordsModule);
        this.ledger = this.container.resolve(LedgerModule_1.LedgerModule);
        this.discovery = this.container.resolve(discover_features_1.DiscoverFeaturesModule);
        this.dids = this.container.resolve(DidsModule_1.DidsModule);
        this.wallet = this.container.resolve(WalletModule_1.WalletModule);
        this.oob = this.container.resolve(OutOfBandModule_1.OutOfBandModule);
        // Listen for new messages (either from transports or somewhere else in the framework / extensions)
        this.messageSubscription = this.eventEmitter
            .observable(Events_1.AgentEventTypes.AgentMessageReceived)
            .pipe(operators_1.takeUntil(this.agentConfig.stop$), operators_1.concatMap((e) => this.messageReceiver.receiveMessage(e.payload.message, { connection: e.payload.connection })))
            .subscribe();
    }
    registerInboundTransport(inboundTransport) {
        this.messageReceiver.registerInboundTransport(inboundTransport);
    }
    get inboundTransports() {
        return this.messageReceiver.inboundTransports;
    }
    registerOutboundTransport(outboundTransport) {
        this.messageSender.registerOutboundTransport(outboundTransport);
    }
    get outboundTransports() {
        return this.messageSender.outboundTransports;
    }
    get events() {
        return this.eventEmitter;
    }
    get isInitialized() {
        return this._isInitialized && this.wallet.isInitialized;
    }
    async initialize() {
        const { connectToIndyLedgersOnStartup, publicDidSeed, walletConfig, mediatorConnectionsInvite } = this.agentConfig;
        if (this._isInitialized) {
            throw new error_1.AriesFrameworkError('Agent already initialized. Currently it is not supported to re-initialize an already initialized agent.');
        }
        if (!this.wallet.isInitialized && walletConfig) {
            await this.wallet.initialize(walletConfig);
        }
        else if (!this.wallet.isInitialized) {
            throw new error_2.WalletError('Wallet config has not been set on the agent config. ' +
                'Make sure to initialize the wallet yourself before initializing the agent, ' +
                'or provide the required wallet configuration in the agent constructor');
        }
        // Make sure the storage is up to date
        const storageUpdateService = this.container.resolve(storage_1.StorageUpdateService);
        const isStorageUpToDate = await storageUpdateService.isUpToDate();
        this.logger.info(`Agent storage is ${isStorageUpToDate ? '' : 'not '}up to date.`);
        if (!isStorageUpToDate && this.agentConfig.autoUpdateStorageOnStartup) {
            const updateAssistant = new UpdateAssistant_1.UpdateAssistant(this, updates_1.DEFAULT_UPDATE_CONFIG);
            await updateAssistant.initialize();
            await updateAssistant.update();
        }
        else if (!isStorageUpToDate) {
            const currentVersion = await storageUpdateService.getCurrentStorageVersion();
            // Close wallet to prevent un-initialized agent with initialized wallet
            await this.wallet.close();
            throw new error_1.AriesFrameworkError(
            // TODO: add link to where documentation on how to update can be found.
            `Current agent storage is not up to date. ` +
                `To prevent the framework state from getting corrupted the agent initialization is aborted. ` +
                `Make sure to update the agent storage (currently at ${currentVersion}) to the latest version (${UpdateAssistant_1.UpdateAssistant.frameworkStorageVersion}). ` +
                `You can also downgrade your version of Aries Framework JavaScript.`);
        }
        if (publicDidSeed) {
            // If an agent has publicDid it will be used as routing key.
            await this.walletService.initPublicDid({ seed: publicDidSeed });
        }
        // As long as value isn't false we will async connect to all genesis pools on startup
        if (connectToIndyLedgersOnStartup) {
            this.ledger.connectToPools().catch((error) => {
                this.logger.warn('Error connecting to ledger, will try to reconnect when needed.', { error });
            });
        }
        for (const transport of this.inboundTransports) {
            await transport.start(this);
        }
        for (const transport of this.outboundTransports) {
            await transport.start(this);
        }
        // Connect to mediator through provided invitation if provided in config
        // Also requests mediation ans sets as default mediator
        // Because this requires the connections module, we do this in the agent constructor
        if (mediatorConnectionsInvite) {
            this.logger.debug('Provision mediation with invitation', { mediatorConnectionsInvite });
            const mediationConnection = await this.getMediationConnection(mediatorConnectionsInvite);
            await this.mediationRecipient.provision(mediationConnection);
        }
        await this.mediationRecipient.initialize();
        this._isInitialized = true;
    }
    async shutdown() {
        // All observables use takeUntil with the stop$ observable
        // this means all observables will stop running if a value is emitted on this observable
        this.agentConfig.stop$.next(true);
        // Stop transports
        const allTransports = [...this.inboundTransports, ...this.outboundTransports];
        const transportPromises = allTransports.map((transport) => transport.stop());
        await Promise.all(transportPromises);
        // close wallet if still initialized
        if (this.wallet.isInitialized) {
            await this.wallet.close();
        }
        this._isInitialized = false;
    }
    get publicDid() {
        return this.walletService.publicDid;
    }
    async receiveMessage(inboundMessage, session) {
        return await this.messageReceiver.receiveMessage(inboundMessage, { session });
    }
    get injectionContainer() {
        return this.container;
    }
    get config() {
        return this.agentConfig;
    }
    async getMediationConnection(mediatorInvitationUrl) {
        const outOfBandInvitation = this.oob.parseInvitation(mediatorInvitationUrl);
        const outOfBandRecord = await this.oob.findByInvitationId(outOfBandInvitation.id);
        const [connection] = outOfBandRecord ? await this.connections.findAllByOutOfBandId(outOfBandRecord.id) : [];
        if (!connection) {
            this.logger.debug('Mediation connection does not exist, creating connection');
            // We don't want to use the current default mediator when connecting to another mediator
            const routing = await this.mediationRecipient.getRouting({ useDefaultMediator: false });
            this.logger.debug('Routing created', routing);
            const { connectionRecord: newConnection } = await this.oob.receiveInvitation(outOfBandInvitation, {
                routing,
            });
            this.logger.debug(`Mediation invitation processed`, { outOfBandInvitation });
            if (!newConnection) {
                throw new error_1.AriesFrameworkError('No connection record to provision mediation.');
            }
            return this.connections.returnWhenIsConnected(newConnection.id);
        }
        if (!connection.isReady) {
            return this.connections.returnWhenIsConnected(connection.id);
        }
        return connection;
    }
}
exports.Agent = Agent;
//# sourceMappingURL=Agent.js.map