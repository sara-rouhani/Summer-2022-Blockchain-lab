"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.DidExchangeProtocol = void 0;
const tsyringe_1 = require("tsyringe");
const AgentConfig_1 = require("../../agent/AgentConfig");
const crypto_1 = require("../../crypto");
const JwsService_1 = require("../../crypto/JwsService");
const Attachment_1 = require("../../decorators/attachment/Attachment");
const error_1 = require("../../error");
const JsonEncoder_1 = require("../../utils/JsonEncoder");
const JsonTransformer_1 = require("../../utils/JsonTransformer");
const dids_1 = require("../dids");
const DidDocumentRole_1 = require("../dids/domain/DidDocumentRole");
const createPeerDidFromServices_1 = require("../dids/domain/createPeerDidFromServices");
const key_type_1 = require("../dids/domain/key-type");
const helpers_1 = require("../dids/helpers");
const DidKey_1 = require("../dids/methods/key/DidKey");
const didPeer_1 = require("../dids/methods/peer/didPeer");
const peerDidNumAlgo1_1 = require("../dids/methods/peer/peerDidNumAlgo1");
const repository_1 = require("../dids/repository");
const OutOfBandRole_1 = require("../oob/domain/OutOfBandRole");
const OutOfBandState_1 = require("../oob/domain/OutOfBandState");
const DidExchangeStateMachine_1 = require("./DidExchangeStateMachine");
const errors_1 = require("./errors");
const DidExchangeCompleteMessage_1 = require("./messages/DidExchangeCompleteMessage");
const DidExchangeRequestMessage_1 = require("./messages/DidExchangeRequestMessage");
const DidExchangeResponseMessage_1 = require("./messages/DidExchangeResponseMessage");
const models_1 = require("./models");
const services_1 = require("./services");
let DidExchangeProtocol = class DidExchangeProtocol {
    constructor(config, connectionService, didRepository, jwsService) {
        this.config = config;
        this.connectionService = connectionService;
        this.didRepository = didRepository;
        this.jwsService = jwsService;
        this.logger = config.logger;
    }
    async createRequest(outOfBandRecord, params) {
        var _a, _b;
        this.logger.debug(`Create message ${DidExchangeRequestMessage_1.DidExchangeRequestMessage.type.messageTypeUri} start`, {
            outOfBandRecord,
            params,
        });
        const { outOfBandInvitation } = outOfBandRecord;
        const { alias, goal, goalCode, routing, autoAcceptConnection } = params;
        // TODO: We should store only one did that we'll use to send the request message with success.
        // We take just the first one for now.
        const [invitationDid] = outOfBandInvitation.invitationDids;
        const connectionRecord = await this.connectionService.createConnection({
            protocol: models_1.HandshakeProtocol.DidExchange,
            role: models_1.DidExchangeRole.Requester,
            alias,
            state: models_1.DidExchangeState.InvitationReceived,
            theirLabel: outOfBandInvitation.label,
            mediatorId: (_a = routing.mediatorId) !== null && _a !== void 0 ? _a : outOfBandRecord.mediatorId,
            autoAcceptConnection: outOfBandRecord.autoAcceptConnection,
            outOfBandId: outOfBandRecord.id,
            invitationDid,
        });
        DidExchangeStateMachine_1.DidExchangeStateMachine.assertCreateMessageState(DidExchangeRequestMessage_1.DidExchangeRequestMessage.type, connectionRecord);
        // Create message
        const label = (_b = params.label) !== null && _b !== void 0 ? _b : this.config.label;
        const didDocument = await this.createPeerDidDoc(this.routingToServices(routing));
        const parentThreadId = outOfBandInvitation.id;
        const message = new DidExchangeRequestMessage_1.DidExchangeRequestMessage({ label, parentThreadId, did: didDocument.id, goal, goalCode });
        // Create sign attachment containing didDoc
        if (didPeer_1.getNumAlgoFromPeerDid(didDocument.id) === didPeer_1.PeerDidNumAlgo.GenesisDoc) {
            const didDocAttach = await this.createSignedAttachment(didDocument, [routing.recipientKey.publicKeyBase58]);
            message.didDoc = didDocAttach;
        }
        connectionRecord.did = didDocument.id;
        connectionRecord.threadId = message.id;
        if (autoAcceptConnection !== undefined || autoAcceptConnection !== null) {
            connectionRecord.autoAcceptConnection = autoAcceptConnection;
        }
        await this.updateState(DidExchangeRequestMessage_1.DidExchangeRequestMessage.type, connectionRecord);
        this.logger.debug(`Create message ${DidExchangeRequestMessage_1.DidExchangeRequestMessage.type.messageTypeUri} end`, {
            connectionRecord,
            message,
        });
        return { message, connectionRecord };
    }
    async processRequest(messageContext, outOfBandRecord) {
        var _a, _b;
        this.logger.debug(`Process message ${DidExchangeRequestMessage_1.DidExchangeRequestMessage.type.messageTypeUri} start`, messageContext);
        outOfBandRecord.assertRole(OutOfBandRole_1.OutOfBandRole.Sender);
        outOfBandRecord.assertState(OutOfBandState_1.OutOfBandState.AwaitResponse);
        // TODO check there is no connection record for particular oob record
        const { message } = messageContext;
        // Check corresponding invitation ID is the request's ~thread.pthid
        // TODO Maybe we can do it in handler, but that actually does not make sense because we try to find oob by parent thread ID there.
        if (!((_a = message.thread) === null || _a === void 0 ? void 0 : _a.parentThreadId) || ((_b = message.thread) === null || _b === void 0 ? void 0 : _b.parentThreadId) !== outOfBandRecord.getTags().invitationId) {
            throw new errors_1.DidExchangeProblemReportError('Missing reference to invitation.', {
                problemCode: errors_1.DidExchangeProblemReportReason.RequestNotAccepted,
            });
        }
        // If the responder wishes to continue the exchange, they will persist the received information in their wallet.
        if (!message.did.startsWith('did:peer:')) {
            throw new errors_1.DidExchangeProblemReportError(`Message contains unsupported did ${message.did}. Supported dids are [did:peer]`, {
                problemCode: errors_1.DidExchangeProblemReportReason.RequestNotAccepted,
            });
        }
        const numAlgo = didPeer_1.getNumAlgoFromPeerDid(message.did);
        if (numAlgo !== didPeer_1.PeerDidNumAlgo.GenesisDoc) {
            throw new errors_1.DidExchangeProblemReportError(`Unsupported numalgo ${numAlgo}. Supported numalgos are [${didPeer_1.PeerDidNumAlgo.GenesisDoc}]`, {
                problemCode: errors_1.DidExchangeProblemReportReason.RequestNotAccepted,
            });
        }
        const didDocument = await this.extractDidDocument(message);
        const didRecord = new repository_1.DidRecord({
            id: message.did,
            role: DidDocumentRole_1.DidDocumentRole.Received,
            // It is important to take the did document from the PeerDid class
            // as it will have the id property
            didDocument,
            tags: {
                // We need to save the recipientKeys, so we can find the associated did
                // of a key when we receive a message from another connection.
                recipientKeyFingerprints: didDocument.recipientKeys.map((key) => key.fingerprint),
            },
        });
        this.logger.debug('Saving DID record', {
            id: didRecord.id,
            role: didRecord.role,
            tags: didRecord.getTags(),
            didDocument: 'omitted...',
        });
        await this.didRepository.save(didRecord);
        const connectionRecord = await this.connectionService.createConnection({
            protocol: models_1.HandshakeProtocol.DidExchange,
            role: models_1.DidExchangeRole.Responder,
            state: models_1.DidExchangeState.RequestReceived,
            theirDid: message.did,
            theirLabel: message.label,
            threadId: message.threadId,
            mediatorId: outOfBandRecord.mediatorId,
            autoAcceptConnection: outOfBandRecord.autoAcceptConnection,
            outOfBandId: outOfBandRecord.id,
        });
        await this.updateState(DidExchangeRequestMessage_1.DidExchangeRequestMessage.type, connectionRecord);
        this.logger.debug(`Process message ${DidExchangeRequestMessage_1.DidExchangeRequestMessage.type.messageTypeUri} end`, connectionRecord);
        return connectionRecord;
    }
    async createResponse(connectionRecord, outOfBandRecord, routing) {
        this.logger.debug(`Create message ${DidExchangeResponseMessage_1.DidExchangeResponseMessage.type.messageTypeUri} start`, connectionRecord);
        DidExchangeStateMachine_1.DidExchangeStateMachine.assertCreateMessageState(DidExchangeResponseMessage_1.DidExchangeResponseMessage.type, connectionRecord);
        const { threadId } = connectionRecord;
        if (!threadId) {
            throw new error_1.AriesFrameworkError('Missing threadId on connection record.');
        }
        let services = [];
        if (routing) {
            services = this.routingToServices(routing);
        }
        else if (outOfBandRecord) {
            const inlineServices = outOfBandRecord.outOfBandInvitation.services.filter((service) => typeof service !== 'string');
            services = inlineServices.map((service) => {
                var _a, _b;
                return ({
                    id: service.id,
                    serviceEndpoint: service.serviceEndpoint,
                    recipientKeys: service.recipientKeys.map(helpers_1.didKeyToInstanceOfKey),
                    routingKeys: (_b = (_a = service.routingKeys) === null || _a === void 0 ? void 0 : _a.map(helpers_1.didKeyToInstanceOfKey)) !== null && _b !== void 0 ? _b : [],
                });
            });
        }
        const didDocument = await this.createPeerDidDoc(services);
        const message = new DidExchangeResponseMessage_1.DidExchangeResponseMessage({ did: didDocument.id, threadId });
        if (didPeer_1.getNumAlgoFromPeerDid(didDocument.id) === didPeer_1.PeerDidNumAlgo.GenesisDoc) {
            const didDocAttach = await this.createSignedAttachment(didDocument, Array.from(new Set(services
                .map((s) => s.recipientKeys)
                .reduce((acc, curr) => acc.concat(curr), [])
                .map((key) => key.publicKeyBase58))));
            message.didDoc = didDocAttach;
        }
        connectionRecord.did = didDocument.id;
        await this.updateState(DidExchangeResponseMessage_1.DidExchangeResponseMessage.type, connectionRecord);
        this.logger.debug(`Create message ${DidExchangeResponseMessage_1.DidExchangeResponseMessage.type.messageTypeUri} end`, {
            connectionRecord,
            message,
        });
        return message;
    }
    async processResponse(messageContext, outOfBandRecord) {
        var _a, _b;
        this.logger.debug(`Process message ${DidExchangeResponseMessage_1.DidExchangeResponseMessage.type.messageTypeUri} start`, messageContext);
        const { connection: connectionRecord, message } = messageContext;
        if (!connectionRecord) {
            throw new error_1.AriesFrameworkError('No connection record in message context.');
        }
        DidExchangeStateMachine_1.DidExchangeStateMachine.assertProcessMessageState(DidExchangeResponseMessage_1.DidExchangeResponseMessage.type, connectionRecord);
        if (!((_a = message.thread) === null || _a === void 0 ? void 0 : _a.threadId) || ((_b = message.thread) === null || _b === void 0 ? void 0 : _b.threadId) !== connectionRecord.threadId) {
            throw new errors_1.DidExchangeProblemReportError('Invalid or missing thread ID.', {
                problemCode: errors_1.DidExchangeProblemReportReason.ResponseNotAccepted,
            });
        }
        if (!message.did.startsWith('did:peer:')) {
            throw new errors_1.DidExchangeProblemReportError(`Message contains unsupported did ${message.did}. Supported dids are [did:peer]`, {
                problemCode: errors_1.DidExchangeProblemReportReason.ResponseNotAccepted,
            });
        }
        const numAlgo = didPeer_1.getNumAlgoFromPeerDid(message.did);
        if (numAlgo !== didPeer_1.PeerDidNumAlgo.GenesisDoc) {
            throw new errors_1.DidExchangeProblemReportError(`Unsupported numalgo ${numAlgo}. Supported numalgos are [${didPeer_1.PeerDidNumAlgo.GenesisDoc}]`, {
                problemCode: errors_1.DidExchangeProblemReportReason.ResponseNotAccepted,
            });
        }
        const didDocument = await this.extractDidDocument(message, outOfBandRecord.outOfBandInvitation.getRecipientKeys().map((key) => key.publicKeyBase58));
        const didRecord = new repository_1.DidRecord({
            id: message.did,
            role: DidDocumentRole_1.DidDocumentRole.Received,
            didDocument,
            tags: {
                // We need to save the recipientKeys, so we can find the associated did
                // of a key when we receive a message from another connection.
                recipientKeyFingerprints: didDocument.recipientKeys.map((key) => key.fingerprint),
            },
        });
        this.logger.debug('Saving DID record', {
            id: didRecord.id,
            role: didRecord.role,
            tags: didRecord.getTags(),
            didDocument: 'omitted...',
        });
        await this.didRepository.save(didRecord);
        connectionRecord.theirDid = message.did;
        await this.updateState(DidExchangeResponseMessage_1.DidExchangeResponseMessage.type, connectionRecord);
        this.logger.debug(`Process message ${DidExchangeResponseMessage_1.DidExchangeResponseMessage.type.messageTypeUri} end`, connectionRecord);
        return connectionRecord;
    }
    async createComplete(connectionRecord, outOfBandRecord) {
        this.logger.debug(`Create message ${DidExchangeCompleteMessage_1.DidExchangeCompleteMessage.type.messageTypeUri} start`, connectionRecord);
        DidExchangeStateMachine_1.DidExchangeStateMachine.assertCreateMessageState(DidExchangeCompleteMessage_1.DidExchangeCompleteMessage.type, connectionRecord);
        const threadId = connectionRecord.threadId;
        const parentThreadId = outOfBandRecord.outOfBandInvitation.id;
        if (!threadId) {
            throw new error_1.AriesFrameworkError(`Connection record ${connectionRecord.id} does not have 'threadId' attribute.`);
        }
        if (!parentThreadId) {
            throw new error_1.AriesFrameworkError(`Connection record ${connectionRecord.id} does not have 'parentThreadId' attribute.`);
        }
        const message = new DidExchangeCompleteMessage_1.DidExchangeCompleteMessage({ threadId, parentThreadId });
        await this.updateState(DidExchangeCompleteMessage_1.DidExchangeCompleteMessage.type, connectionRecord);
        this.logger.debug(`Create message ${DidExchangeCompleteMessage_1.DidExchangeCompleteMessage.type.messageTypeUri} end`, {
            connectionRecord,
            message,
        });
        return message;
    }
    async processComplete(messageContext, outOfBandRecord) {
        var _a, _b;
        this.logger.debug(`Process message ${DidExchangeCompleteMessage_1.DidExchangeCompleteMessage.type.messageTypeUri} start`, messageContext);
        const { connection: connectionRecord, message } = messageContext;
        if (!connectionRecord) {
            throw new error_1.AriesFrameworkError('No connection record in message context.');
        }
        DidExchangeStateMachine_1.DidExchangeStateMachine.assertProcessMessageState(DidExchangeCompleteMessage_1.DidExchangeCompleteMessage.type, connectionRecord);
        if (message.threadId !== connectionRecord.threadId) {
            throw new errors_1.DidExchangeProblemReportError('Invalid or missing thread ID.', {
                problemCode: errors_1.DidExchangeProblemReportReason.CompleteRejected,
            });
        }
        if (!((_a = message.thread) === null || _a === void 0 ? void 0 : _a.parentThreadId) || ((_b = message.thread) === null || _b === void 0 ? void 0 : _b.parentThreadId) !== outOfBandRecord.getTags().invitationId) {
            throw new errors_1.DidExchangeProblemReportError('Invalid or missing parent thread ID referencing to the invitation.', {
                problemCode: errors_1.DidExchangeProblemReportReason.CompleteRejected,
            });
        }
        await this.updateState(DidExchangeCompleteMessage_1.DidExchangeCompleteMessage.type, connectionRecord);
        this.logger.debug(`Process message ${DidExchangeCompleteMessage_1.DidExchangeCompleteMessage.type.messageTypeUri} end`, { connectionRecord });
        return connectionRecord;
    }
    async updateState(messageType, connectionRecord) {
        this.logger.debug(`Updating state`, { connectionRecord });
        const nextState = DidExchangeStateMachine_1.DidExchangeStateMachine.nextState(messageType, connectionRecord);
        return this.connectionService.updateState(connectionRecord, nextState);
    }
    async createPeerDidDoc(services) {
        const didDocument = createPeerDidFromServices_1.createDidDocumentFromServices(services);
        const peerDid = peerDidNumAlgo1_1.didDocumentJsonToNumAlgo1Did(didDocument.toJSON());
        didDocument.id = peerDid;
        const didRecord = new repository_1.DidRecord({
            id: peerDid,
            role: DidDocumentRole_1.DidDocumentRole.Created,
            didDocument,
            tags: {
                // We need to save the recipientKeys, so we can find the associated did
                // of a key when we receive a message from another connection.
                recipientKeyFingerprints: didDocument.recipientKeys.map((key) => key.fingerprint),
            },
        });
        this.logger.debug('Saving DID record', {
            id: didRecord.id,
            role: didRecord.role,
            tags: didRecord.getTags(),
            didDocument: 'omitted...',
        });
        await this.didRepository.save(didRecord);
        this.logger.debug('Did record created.', didRecord);
        return didDocument;
    }
    async createSignedAttachment(didDoc, verkeys) {
        const didDocAttach = new Attachment_1.Attachment({
            mimeType: 'application/json',
            data: new Attachment_1.AttachmentData({
                base64: JsonEncoder_1.JsonEncoder.toBase64(didDoc),
            }),
        });
        await Promise.all(verkeys.map(async (verkey) => {
            const key = dids_1.Key.fromPublicKeyBase58(verkey, crypto_1.KeyType.Ed25519);
            const kid = new DidKey_1.DidKey(key).did;
            const payload = JsonEncoder_1.JsonEncoder.toBuffer(didDoc);
            const jws = await this.jwsService.createJws({
                payload,
                verkey,
                header: {
                    kid,
                },
            });
            didDocAttach.addJws(jws);
        }));
        return didDocAttach;
    }
    /**
     * Extracts DID document as is from request or response message attachment and verifies its signature.
     *
     * @param message DID request or DID response message
     * @param invitationKeys array containing keys from connection invitation that could be used for signing of DID document
     * @returns verified DID document content from message attachment
     */
    async extractDidDocument(message, invitationKeysBase58 = []) {
        var _a;
        if (!message.didDoc) {
            const problemCode = message instanceof DidExchangeRequestMessage_1.DidExchangeRequestMessage
                ? errors_1.DidExchangeProblemReportReason.RequestNotAccepted
                : errors_1.DidExchangeProblemReportReason.ResponseNotAccepted;
            throw new errors_1.DidExchangeProblemReportError('DID Document attachment is missing.', { problemCode });
        }
        const didDocumentAttachment = message.didDoc;
        const jws = didDocumentAttachment.data.jws;
        if (!jws) {
            const problemCode = message instanceof DidExchangeRequestMessage_1.DidExchangeRequestMessage
                ? errors_1.DidExchangeProblemReportReason.RequestNotAccepted
                : errors_1.DidExchangeProblemReportReason.ResponseNotAccepted;
            throw new errors_1.DidExchangeProblemReportError('DID Document signature is missing.', { problemCode });
        }
        const json = didDocumentAttachment.getDataAsJson();
        this.logger.trace('DidDocument JSON', json);
        const payload = JsonEncoder_1.JsonEncoder.toBuffer(json);
        const { isValid, signerVerkeys } = await this.jwsService.verifyJws({ jws, payload });
        const didDocument = JsonTransformer_1.JsonTransformer.fromJSON(json, dids_1.DidDocument);
        const didDocumentKeysBase58 = (_a = didDocument.authentication) === null || _a === void 0 ? void 0 : _a.map((authentication) => {
            const verificationMethod = typeof authentication === 'string'
                ? didDocument.dereferenceVerificationMethod(authentication)
                : authentication;
            const { getKeyFromVerificationMethod } = key_type_1.getKeyDidMappingByVerificationMethod(verificationMethod);
            const key = getKeyFromVerificationMethod(verificationMethod);
            return key.publicKeyBase58;
        }).concat(invitationKeysBase58);
        this.logger.trace('JWS verification result', { isValid, signerVerkeys, didDocumentKeysBase58 });
        if (!isValid || !signerVerkeys.every((verkey) => didDocumentKeysBase58 === null || didDocumentKeysBase58 === void 0 ? void 0 : didDocumentKeysBase58.includes(verkey))) {
            const problemCode = message instanceof DidExchangeRequestMessage_1.DidExchangeRequestMessage
                ? errors_1.DidExchangeProblemReportReason.RequestNotAccepted
                : errors_1.DidExchangeProblemReportReason.ResponseNotAccepted;
            throw new errors_1.DidExchangeProblemReportError('DID Document signature is invalid.', { problemCode });
        }
        return didDocument;
    }
    routingToServices(routing) {
        return routing.endpoints.map((endpoint, index) => ({
            id: `#inline-${index}`,
            serviceEndpoint: endpoint,
            recipientKeys: [routing.recipientKey],
            routingKeys: routing.routingKeys,
        }));
    }
};
DidExchangeProtocol = __decorate([
    tsyringe_1.scoped(tsyringe_1.Lifecycle.ContainerScoped),
    __metadata("design:paramtypes", [AgentConfig_1.AgentConfig,
        services_1.ConnectionService,
        repository_1.DidRepository,
        JwsService_1.JwsService])
], DidExchangeProtocol);
exports.DidExchangeProtocol = DidExchangeProtocol;
//# sourceMappingURL=DidExchangeProtocol.js.map