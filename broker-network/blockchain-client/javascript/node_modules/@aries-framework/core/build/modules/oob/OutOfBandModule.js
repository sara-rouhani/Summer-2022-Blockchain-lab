"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.OutOfBandModule = void 0;
const rxjs_1 = require("rxjs");
const tsyringe_1 = require("tsyringe");
const AgentConfig_1 = require("../../agent/AgentConfig");
const Dispatcher_1 = require("../../agent/Dispatcher");
const EventEmitter_1 = require("../../agent/EventEmitter");
const Events_1 = require("../../agent/Events");
const MessageSender_1 = require("../../agent/MessageSender");
const helpers_1 = require("../../agent/helpers");
const ServiceDecorator_1 = require("../../decorators/service/ServiceDecorator");
const error_1 = require("../../error");
const connections_1 = require("../../modules/connections");
const storage_1 = require("../../storage");
const utils_1 = require("../../utils");
const messageType_1 = require("../../utils/messageType");
const parseInvitation_1 = require("../../utils/parseInvitation");
const dids_1 = require("../dids");
const helpers_2 = require("../dids/helpers");
const peerDidNumAlgo2_1 = require("../dids/methods/peer/peerDidNumAlgo2");
const routing_1 = require("../routing");
const OutOfBandService_1 = require("./OutOfBandService");
const OutOfBandDidCommService_1 = require("./domain/OutOfBandDidCommService");
const OutOfBandEvents_1 = require("./domain/OutOfBandEvents");
const OutOfBandRole_1 = require("./domain/OutOfBandRole");
const OutOfBandState_1 = require("./domain/OutOfBandState");
const handlers_1 = require("./handlers");
const HandshakeReuseAcceptedHandler_1 = require("./handlers/HandshakeReuseAcceptedHandler");
const helpers_3 = require("./helpers");
const messages_1 = require("./messages");
const OutOfBandRecord_1 = require("./repository/OutOfBandRecord");
const didCommProfiles = ['didcomm/aip1', 'didcomm/aip2;env=rfc19'];
let OutOfBandModule = class OutOfBandModule {
    constructor(dispatcher, agentConfig, outOfBandService, mediationRecipientService, connectionsModule, didCommMessageRepository, messageSender, eventEmitter) {
        this.dispatcher = dispatcher;
        this.agentConfig = agentConfig;
        this.logger = agentConfig.logger;
        this.outOfBandService = outOfBandService;
        this.mediationRecipientService = mediationRecipientService;
        this.connectionsModule = connectionsModule;
        this.didCommMessageRepository = didCommMessageRepository;
        this.messageSender = messageSender;
        this.eventEmitter = eventEmitter;
        this.registerHandlers(dispatcher);
    }
    /**
     * Creates an outbound out-of-band record containing out-of-band invitation message defined in
     * Aries RFC 0434: Out-of-Band Protocol 1.1.
     *
     * It automatically adds all supported handshake protocols by agent to `handshake_protocols`. You
     * can modify this by setting `handshakeProtocols` in `config` parameter. If you want to create
     * invitation without handshake, you can set `handshake` to `false`.
     *
     * If `config` parameter contains `messages` it adds them to `requests~attach` attribute.
     *
     * Agent role: sender (inviter)
     *
     * @param config configuration of how out-of-band invitation should be created
     * @returns out-of-band record
     */
    async createInvitation(config = {}) {
        var _a, _b, _c, _d, _e, _f;
        const multiUseInvitation = (_a = config.multiUseInvitation) !== null && _a !== void 0 ? _a : false;
        const handshake = (_b = config.handshake) !== null && _b !== void 0 ? _b : true;
        const customHandshakeProtocols = config.handshakeProtocols;
        const autoAcceptConnection = (_c = config.autoAcceptConnection) !== null && _c !== void 0 ? _c : this.agentConfig.autoAcceptConnections;
        // We don't want to treat an empty array as messages being provided
        const messages = config.messages && config.messages.length > 0 ? config.messages : undefined;
        const label = (_d = config.label) !== null && _d !== void 0 ? _d : this.agentConfig.label;
        const imageUrl = (_e = config.imageUrl) !== null && _e !== void 0 ? _e : this.agentConfig.connectionImageUrl;
        if (!handshake && !messages) {
            throw new error_1.AriesFrameworkError('One or both of handshake_protocols and requests~attach MUST be included in the message.');
        }
        if (!handshake && customHandshakeProtocols) {
            throw new error_1.AriesFrameworkError(`Attribute 'handshake' can not be 'false' when 'handshakeProtocols' is defined.`);
        }
        // For now we disallow creating multi-use invitation with attachments. This would mean we need multi-use
        // credential and presentation exchanges.
        if (messages && multiUseInvitation) {
            throw new error_1.AriesFrameworkError("Attribute 'multiUseInvitation' can not be 'true' when 'messages' is defined.");
        }
        let handshakeProtocols;
        if (handshake) {
            // Find supported handshake protocol preserving the order of handshake protocols defined
            // by agent
            if (customHandshakeProtocols) {
                this.assertHandshakeProtocols(customHandshakeProtocols);
                handshakeProtocols = customHandshakeProtocols;
            }
            else {
                handshakeProtocols = this.getSupportedHandshakeProtocols();
            }
        }
        const routing = (_f = config.routing) !== null && _f !== void 0 ? _f : (await this.mediationRecipientService.getRouting({}));
        const services = routing.endpoints.map((endpoint, index) => {
            return new OutOfBandDidCommService_1.OutOfBandDidCommService({
                id: `#inline-${index}`,
                serviceEndpoint: endpoint,
                recipientKeys: [routing.recipientKey].map((key) => new dids_1.DidKey(key).did),
                routingKeys: routing.routingKeys.map((key) => new dids_1.DidKey(key).did),
            });
        });
        const options = {
            label,
            goal: config.goal,
            goalCode: config.goalCode,
            imageUrl,
            accept: didCommProfiles,
            services,
            handshakeProtocols,
        };
        const outOfBandInvitation = new messages_1.OutOfBandInvitation(options);
        if (messages) {
            messages.forEach((message) => {
                if (message.service) {
                    // We can remove `~service` attribute from message. Newer OOB messages have `services` attribute instead.
                    message.service = undefined;
                }
                outOfBandInvitation.addRequest(message);
            });
        }
        const outOfBandRecord = new OutOfBandRecord_1.OutOfBandRecord({
            mediatorId: routing.mediatorId,
            role: OutOfBandRole_1.OutOfBandRole.Sender,
            state: OutOfBandState_1.OutOfBandState.AwaitResponse,
            outOfBandInvitation: outOfBandInvitation,
            reusable: multiUseInvitation,
            autoAcceptConnection,
        });
        await this.outOfBandService.save(outOfBandRecord);
        this.outOfBandService.emitStateChangedEvent(outOfBandRecord, null);
        return outOfBandRecord;
    }
    /**
     * Creates an outbound out-of-band record in the same way how `createInvitation` method does it,
     * but it also converts out-of-band invitation message to an "legacy" invitation message defined
     * in RFC 0160: Connection Protocol and returns it together with out-of-band record.
     *
     * Agent role: sender (inviter)
     *
     * @param config configuration of how a connection invitation should be created
     * @returns out-of-band record and connection invitation
     */
    async createLegacyInvitation(config = {}) {
        const outOfBandRecord = await this.createInvitation(Object.assign(Object.assign({}, config), { handshakeProtocols: [connections_1.HandshakeProtocol.Connections] }));
        return { outOfBandRecord, invitation: helpers_3.convertToOldInvitation(outOfBandRecord.outOfBandInvitation) };
    }
    async createLegacyConnectionlessInvitation(config) {
        // Create keys (and optionally register them at the mediator)
        const routing = await this.mediationRecipientService.getRouting();
        // Set the service on the message
        config.message.service = new ServiceDecorator_1.ServiceDecorator({
            serviceEndpoint: routing.endpoints[0],
            recipientKeys: [routing.recipientKey].map((key) => key.publicKeyBase58),
            routingKeys: routing.routingKeys.map((key) => key.publicKeyBase58),
        });
        // We need to update the message with the new service, so we can
        // retrieve it from storage later on.
        await this.didCommMessageRepository.saveOrUpdateAgentMessage({
            agentMessage: config.message,
            associatedRecordId: config.recordId,
            role: storage_1.DidCommMessageRole.Sender,
        });
        return {
            message: config.message,
            invitationUrl: `${config.domain}?d_m=${utils_1.JsonEncoder.toBase64URL(utils_1.JsonTransformer.toJSON(config.message))}`,
        };
    }
    /**
     * Parses URL, decodes invitation and calls `receiveMessage` with parsed invitation message.
     *
     * Agent role: receiver (invitee)
     *
     * @param invitationUrl url containing a base64 encoded invitation to receive
     * @param config configuration of how out-of-band invitation should be processed
     * @returns out-of-band record and connection record if one has been created
     */
    receiveInvitationFromUrl(invitationUrl, config = {}) {
        const message = this.parseInvitation(invitationUrl);
        return this.receiveInvitation(message, config);
    }
    /**
     * Parses URL containing encoded invitation and returns invitation message.
     *
     * @param invitationUrl URL containing encoded invitation
     *
     * @returns OutOfBandInvitation
     */
    parseInvitation(invitationUrl) {
        return parseInvitation_1.parseInvitationUrl(invitationUrl);
    }
    /**
     * Creates inbound out-of-band record and assigns out-of-band invitation message to it if the
     * message is valid. It automatically passes out-of-band invitation for further processing to
     * `acceptInvitation` method. If you don't want to do that you can set `autoAcceptInvitation`
     * attribute in `config` parameter to `false` and accept the message later by calling
     * `acceptInvitation`.
     *
     * It supports both OOB (Aries RFC 0434: Out-of-Band Protocol 1.1) and Connection Invitation
     * (0160: Connection Protocol).
     *
     * Agent role: receiver (invitee)
     *
     * @param invitation either OutOfBandInvitation or ConnectionInvitationMessage
     * @param config config for handling of invitation
     *
     * @returns out-of-band record and connection record if one has been created.
     */
    async receiveInvitation(invitation, config = {}) {
        var _a, _b, _c, _d, _e;
        // Convert to out of band invitation if needed
        const outOfBandInvitation = invitation instanceof messages_1.OutOfBandInvitation ? invitation : helpers_3.convertToNewInvitation(invitation);
        const { handshakeProtocols } = outOfBandInvitation;
        const { routing } = config;
        const autoAcceptInvitation = (_a = config.autoAcceptInvitation) !== null && _a !== void 0 ? _a : true;
        const autoAcceptConnection = (_b = config.autoAcceptConnection) !== null && _b !== void 0 ? _b : true;
        const reuseConnection = (_c = config.reuseConnection) !== null && _c !== void 0 ? _c : false;
        const label = (_d = config.label) !== null && _d !== void 0 ? _d : this.agentConfig.label;
        const alias = config.alias;
        const imageUrl = (_e = config.imageUrl) !== null && _e !== void 0 ? _e : this.agentConfig.connectionImageUrl;
        const messages = outOfBandInvitation.getRequests();
        if ((!handshakeProtocols || handshakeProtocols.length === 0) && (!messages || (messages === null || messages === void 0 ? void 0 : messages.length) === 0)) {
            throw new error_1.AriesFrameworkError('One or both of handshake_protocols and requests~attach MUST be included in the message.');
        }
        // Make sure we haven't processed this invitation before.
        let outOfBandRecord = await this.findByInvitationId(outOfBandInvitation.id);
        if (outOfBandRecord) {
            throw new error_1.AriesFrameworkError(`An out of band record with invitation ${outOfBandInvitation.id} already exists. Invitations should have a unique id.`);
        }
        outOfBandRecord = new OutOfBandRecord_1.OutOfBandRecord({
            role: OutOfBandRole_1.OutOfBandRole.Receiver,
            state: OutOfBandState_1.OutOfBandState.Initial,
            outOfBandInvitation: outOfBandInvitation,
            autoAcceptConnection,
        });
        await this.outOfBandService.save(outOfBandRecord);
        this.outOfBandService.emitStateChangedEvent(outOfBandRecord, null);
        if (autoAcceptInvitation) {
            return await this.acceptInvitation(outOfBandRecord.id, {
                label,
                alias,
                imageUrl,
                autoAcceptConnection,
                reuseConnection,
                routing,
            });
        }
        return { outOfBandRecord };
    }
    /**
     * Creates a connection if the out-of-band invitation message contains `handshake_protocols`
     * attribute, except for the case when connection already exists and `reuseConnection` is enabled.
     *
     * It passes first supported message from `requests~attach` attribute to the agent, except for the
     * case reuse of connection is applied when it just sends `handshake-reuse` message to existing
     * connection.
     *
     * Agent role: receiver (invitee)
     *
     * @param outOfBandId
     * @param config
     * @returns out-of-band record and connection record if one has been created.
     */
    async acceptInvitation(outOfBandId, config) {
        const outOfBandRecord = await this.outOfBandService.getById(outOfBandId);
        const { outOfBandInvitation } = outOfBandRecord;
        const { label, alias, imageUrl, autoAcceptConnection, reuseConnection, routing } = config;
        const { handshakeProtocols, services } = outOfBandInvitation;
        const messages = outOfBandInvitation.getRequests();
        const existingConnection = await this.findExistingConnection(services);
        await this.outOfBandService.updateState(outOfBandRecord, OutOfBandState_1.OutOfBandState.PrepareResponse);
        if (handshakeProtocols) {
            this.logger.debug('Out of band message contains handshake protocols.');
            let connectionRecord;
            if (existingConnection && reuseConnection) {
                this.logger.debug(`Connection already exists and reuse is enabled. Reusing an existing connection with ID ${existingConnection.id}.`);
                if (!messages) {
                    this.logger.debug('Out of band message does not contain any request messages.');
                    const isHandshakeReuseSuccessful = await this.handleHandshakeReuse(outOfBandRecord, existingConnection);
                    // Handshake reuse was successful
                    if (isHandshakeReuseSuccessful) {
                        this.logger.debug(`Handshake reuse successful. Reusing existing connection ${existingConnection.id}.`);
                        connectionRecord = existingConnection;
                    }
                    else {
                        // Handshake reuse failed. Not setting connection record
                        this.logger.debug(`Handshake reuse failed. Not using existing connection ${existingConnection.id}.`);
                    }
                }
                else {
                    // Handshake reuse because we found a connection and we can respond directly to the message
                    this.logger.debug(`Reusing existing connection ${existingConnection.id}.`);
                    connectionRecord = existingConnection;
                }
            }
            // If no existing connection was found, reuseConnection is false, or we didn't receive a
            // handshake-reuse-accepted message we create a new connection
            if (!connectionRecord) {
                this.logger.debug('Connection does not exist or reuse is disabled. Creating a new connection.');
                // Find first supported handshake protocol preserving the order of handshake protocols
                // defined by `handshake_protocols` attribute in the invitation message
                const handshakeProtocol = this.getFirstSupportedProtocol(handshakeProtocols);
                connectionRecord = await this.connectionsModule.acceptOutOfBandInvitation(outOfBandRecord, {
                    label,
                    alias,
                    imageUrl,
                    autoAcceptConnection,
                    protocol: handshakeProtocol,
                    routing,
                });
            }
            if (messages) {
                this.logger.debug('Out of band message contains request messages.');
                if (connectionRecord.isReady) {
                    await this.emitWithConnection(connectionRecord, messages);
                }
                else {
                    // Wait until the connection is ready and then pass the messages to the agent for further processing
                    this.connectionsModule
                        .returnWhenIsConnected(connectionRecord.id)
                        .then((connectionRecord) => this.emitWithConnection(connectionRecord, messages))
                        .catch((error) => {
                        if (error instanceof rxjs_1.EmptyError) {
                            this.logger.warn(`Agent unsubscribed before connection got into ${connections_1.DidExchangeState.Completed} state`, error);
                        }
                        else {
                            this.logger.error('Promise waiting for the connection to be complete failed.', error);
                        }
                    });
                }
            }
            return { outOfBandRecord, connectionRecord };
        }
        else if (messages) {
            this.logger.debug('Out of band message contains only request messages.');
            if (existingConnection) {
                this.logger.debug('Connection already exists.', { connectionId: existingConnection.id });
                await this.emitWithConnection(existingConnection, messages);
            }
            else {
                await this.emitWithServices(services, messages);
            }
        }
        return { outOfBandRecord };
    }
    async findByRecipientKey(recipientKey) {
        return this.outOfBandService.findByRecipientKey(recipientKey);
    }
    async findByInvitationId(invitationId) {
        return this.outOfBandService.findByInvitationId(invitationId);
    }
    /**
     * Retrieve all out of bands records
     *
     * @returns List containing all  out of band records
     */
    getAll() {
        return this.outOfBandService.getAll();
    }
    /**
     * Retrieve a out of band record by id
     *
     * @param outOfBandId The  out of band record id
     * @throws {RecordNotFoundError} If no record is found
     * @return The out of band record
     *
     */
    getById(outOfBandId) {
        return this.outOfBandService.getById(outOfBandId);
    }
    /**
     * Find an out of band record by id
     *
     * @param outOfBandId the  out of band record id
     * @returns The out of band record or null if not found
     */
    findById(outOfBandId) {
        return this.outOfBandService.findById(outOfBandId);
    }
    /**
     * Delete an out of band record by id
     *
     * @param outOfBandId the out of band record id
     */
    async deleteById(outOfBandId) {
        return this.outOfBandService.deleteById(outOfBandId);
    }
    assertHandshakeProtocols(handshakeProtocols) {
        if (!this.areHandshakeProtocolsSupported(handshakeProtocols)) {
            const supportedProtocols = this.getSupportedHandshakeProtocols();
            throw new error_1.AriesFrameworkError(`Handshake protocols [${handshakeProtocols}] are not supported. Supported protocols are [${supportedProtocols}]`);
        }
    }
    areHandshakeProtocolsSupported(handshakeProtocols) {
        const supportedProtocols = this.getSupportedHandshakeProtocols();
        return handshakeProtocols.every((p) => supportedProtocols.includes(p));
    }
    getSupportedHandshakeProtocols() {
        const handshakeMessageFamilies = ['https://didcomm.org/didexchange', 'https://didcomm.org/connections'];
        const handshakeProtocols = this.dispatcher.filterSupportedProtocolsByMessageFamilies(handshakeMessageFamilies);
        if (handshakeProtocols.length === 0) {
            throw new error_1.AriesFrameworkError('There is no handshake protocol supported. Agent can not create a connection.');
        }
        // Order protocols according to `handshakeMessageFamilies` array
        const orderedProtocols = handshakeMessageFamilies
            .map((messageFamily) => handshakeProtocols.find((p) => p.startsWith(messageFamily)))
            .filter((item) => !!item);
        return orderedProtocols;
    }
    getFirstSupportedProtocol(handshakeProtocols) {
        const supportedProtocols = this.getSupportedHandshakeProtocols();
        const handshakeProtocol = handshakeProtocols.find((p) => supportedProtocols.includes(p));
        if (!handshakeProtocol) {
            throw new error_1.AriesFrameworkError(`Handshake protocols [${handshakeProtocols}] are not supported. Supported protocols are [${supportedProtocols}]`);
        }
        return handshakeProtocol;
    }
    async findExistingConnection(services) {
        this.logger.debug('Searching for an existing connection for out-of-band invitation services.', { services });
        // TODO: for each did we should look for a connection with the invitation did OR a connection with theirDid that matches the service did
        for (const didOrService of services) {
            // We need to check if the service is an instance of string because of limitations from class-validator
            if (typeof didOrService === 'string' || didOrService instanceof String) {
                // TODO await this.connectionsModule.findByTheirDid()
                throw new error_1.AriesFrameworkError('Dids are not currently supported in out-of-band invitation services attribute.');
            }
            const did = peerDidNumAlgo2_1.outOfBandServiceToNumAlgo2Did(didOrService);
            const connections = await this.connectionsModule.findByInvitationDid(did);
            this.logger.debug(`Retrieved ${connections.length} connections for invitation did ${did}`);
            if (connections.length === 1) {
                const [firstConnection] = connections;
                return firstConnection;
            }
            else if (connections.length > 1) {
                this.logger.warn(`There is more than one connection created from invitationDid ${did}. Taking the first one.`);
                const [firstConnection] = connections;
                return firstConnection;
            }
            return null;
        }
    }
    async emitWithConnection(connectionRecord, messages) {
        const supportedMessageTypes = this.dispatcher.supportedMessageTypes;
        const plaintextMessage = messages.find((message) => supportedMessageTypes.find((type) => messageType_1.supportsIncomingMessageType(messageType_1.parseMessageType(message['@type']), type)));
        if (!plaintextMessage) {
            throw new error_1.AriesFrameworkError('There is no message in requests~attach supported by agent.');
        }
        this.logger.debug(`Message with type ${plaintextMessage['@type']} can be processed.`);
        this.eventEmitter.emit({
            type: Events_1.AgentEventTypes.AgentMessageReceived,
            payload: {
                message: plaintextMessage,
                connection: connectionRecord,
            },
        });
    }
    async emitWithServices(services, messages) {
        var _a;
        if (!services || services.length === 0) {
            throw new error_1.AriesFrameworkError(`There are no services. We can not emit messages`);
        }
        const supportedMessageTypes = this.dispatcher.supportedMessageTypes;
        const plaintextMessage = messages.find((message) => supportedMessageTypes.find((type) => messageType_1.supportsIncomingMessageType(messageType_1.parseMessageType(message['@type']), type)));
        if (!plaintextMessage) {
            throw new error_1.AriesFrameworkError('There is no message in requests~attach supported by agent.');
        }
        this.logger.debug(`Message with type ${plaintextMessage['@type']} can be processed.`);
        // The framework currently supports only older OOB messages with `~service` decorator.
        // TODO: support receiving messages with other services so we don't have to transform the service
        // to ~service decorator
        const [service] = services;
        if (typeof service === 'string') {
            throw new error_1.AriesFrameworkError('Dids are not currently supported in out-of-band invitation services attribute.');
        }
        const serviceDecorator = new ServiceDecorator_1.ServiceDecorator({
            recipientKeys: service.recipientKeys.map(helpers_2.didKeyToVerkey),
            routingKeys: ((_a = service.routingKeys) === null || _a === void 0 ? void 0 : _a.map(helpers_2.didKeyToVerkey)) || [],
            serviceEndpoint: service.serviceEndpoint,
        });
        plaintextMessage['~service'] = utils_1.JsonTransformer.toJSON(serviceDecorator);
        this.eventEmitter.emit({
            type: Events_1.AgentEventTypes.AgentMessageReceived,
            payload: {
                message: plaintextMessage,
            },
        });
    }
    async handleHandshakeReuse(outOfBandRecord, connectionRecord) {
        const reuseMessage = await this.outOfBandService.createHandShakeReuse(outOfBandRecord, connectionRecord);
        const reuseAcceptedEventPromise = rxjs_1.firstValueFrom(this.eventEmitter.observable(OutOfBandEvents_1.OutOfBandEventTypes.HandshakeReused).pipe(
        // Find the first reuse event where the handshake reuse accepted matches the reuse message thread
        // TODO: Should we store the reuse state? Maybe we can keep it in memory for now
        rxjs_1.first((event) => event.payload.reuseThreadId === reuseMessage.threadId &&
            event.payload.outOfBandRecord.id === outOfBandRecord.id &&
            event.payload.connectionRecord.id === connectionRecord.id), 
        // If the event is found, we return the value true
        rxjs_1.map(() => true), rxjs_1.timeout(15000), 
        // If timeout is reached, we return false
        rxjs_1.catchError(() => rxjs_1.of(false))));
        const outbound = helpers_1.createOutboundMessage(connectionRecord, reuseMessage);
        await this.messageSender.sendMessage(outbound);
        return reuseAcceptedEventPromise;
    }
    registerHandlers(dispatcher) {
        dispatcher.registerHandler(new handlers_1.HandshakeReuseHandler(this.outOfBandService));
        dispatcher.registerHandler(new HandshakeReuseAcceptedHandler_1.HandshakeReuseAcceptedHandler(this.outOfBandService));
    }
};
OutOfBandModule = __decorate([
    tsyringe_1.scoped(tsyringe_1.Lifecycle.ContainerScoped),
    __metadata("design:paramtypes", [Dispatcher_1.Dispatcher,
        AgentConfig_1.AgentConfig,
        OutOfBandService_1.OutOfBandService,
        routing_1.MediationRecipientService,
        connections_1.ConnectionsModule,
        storage_1.DidCommMessageRepository,
        MessageSender_1.MessageSender,
        EventEmitter_1.EventEmitter])
], OutOfBandModule);
exports.OutOfBandModule = OutOfBandModule;
//# sourceMappingURL=OutOfBandModule.js.map