"use strict";
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SovDidResolver = void 0;
const ed25519_1 = require("@stablelib/ed25519");
const TypedArrayEncoder_1 = require("../../../../utils/TypedArrayEncoder");
const did_1 = require("../../../../utils/did");
const domain_1 = require("../../domain");
const DidDocumentBuilder_1 = require("../../domain/DidDocumentBuilder");
const DidCommV1Service_1 = require("../../domain/service/DidCommV1Service");
const DidCommV2Service_1 = require("../../domain/service/DidCommV2Service");
class SovDidResolver {
    constructor(indyLedgerService) {
        this.supportedMethods = ['sov'];
        this.indyLedgerService = indyLedgerService;
    }
    async resolve(did, parsed) {
        const didDocumentMetadata = {};
        try {
            const nym = await this.indyLedgerService.getPublicDid(parsed.id);
            const endpoints = await this.indyLedgerService.getEndpointsForDid(did);
            const verificationMethodId = `${parsed.did}#key-1`;
            const keyAgreementId = `${parsed.did}#key-agreement-1`;
            const publicKeyBase58 = did_1.getFullVerkey(nym.did, nym.verkey);
            const publicKeyX25519 = TypedArrayEncoder_1.TypedArrayEncoder.toBase58(ed25519_1.convertPublicKeyToX25519(TypedArrayEncoder_1.TypedArrayEncoder.fromBase58(publicKeyBase58)));
            const builder = new DidDocumentBuilder_1.DidDocumentBuilder(parsed.did)
                .addContext('https://w3id.org/security/suites/ed25519-2018/v1')
                .addContext('https://w3id.org/security/suites/x25519-2019/v1')
                .addVerificationMethod({
                controller: parsed.did,
                id: verificationMethodId,
                publicKeyBase58: did_1.getFullVerkey(nym.did, nym.verkey),
                type: 'Ed25519VerificationKey2018',
            })
                .addVerificationMethod({
                controller: parsed.did,
                id: keyAgreementId,
                publicKeyBase58: publicKeyX25519,
                type: 'X25519KeyAgreementKey2019',
            })
                .addAuthentication(verificationMethodId)
                .addAssertionMethod(verificationMethodId)
                .addKeyAgreement(keyAgreementId);
            this.addServices(builder, parsed, endpoints, keyAgreementId);
            return {
                didDocument: builder.build(),
                didDocumentMetadata,
                didResolutionMetadata: { contentType: 'application/did+ld+json' },
            };
        }
        catch (error) {
            return {
                didDocument: null,
                didDocumentMetadata,
                didResolutionMetadata: {
                    error: 'notFound',
                    message: `resolver_error: Unable to resolve did '${did}': ${error}`,
                },
            };
        }
    }
    // Process Indy Attrib Endpoint Types according to: https://sovrin-foundation.github.io/sovrin/spec/did-method-spec-template.html > Read (Resolve) > DID Service Endpoint
    processEndpointTypes(types) {
        const expectedTypes = ['endpoint', 'did-communication', 'DIDComm'];
        const defaultTypes = ['endpoint', 'did-communication'];
        // Return default types if types "is NOT present [or] empty"
        if (!types || (types === null || types === void 0 ? void 0 : types.length) <= 0) {
            return defaultTypes;
        }
        // Return default types if types "contain any other values"
        for (const type of types) {
            if (!expectedTypes.includes(type)) {
                return defaultTypes;
            }
        }
        // Return provided types
        return types;
    }
    addServices(builder, parsed, endpoints, keyAgreementId) {
        const { endpoint, routingKeys, types } = endpoints, otherEndpoints = __rest(endpoints, ["endpoint", "routingKeys", "types"]);
        if (endpoint) {
            const processedTypes = this.processEndpointTypes(types);
            // If 'endpoint' included in types, add id to the services array
            if (processedTypes.includes('endpoint')) {
                builder.addService(new domain_1.DidDocumentService({
                    id: `${parsed.did}#endpoint`,
                    serviceEndpoint: endpoint,
                    type: 'endpoint',
                }));
            }
            // If 'did-communication' included in types, add DIDComm v1 entry
            if (processedTypes.includes('did-communication')) {
                builder.addService(new DidCommV1Service_1.DidCommV1Service({
                    id: `${parsed.did}#did-communication`,
                    serviceEndpoint: endpoint,
                    priority: 0,
                    routingKeys: routingKeys !== null && routingKeys !== void 0 ? routingKeys : [],
                    recipientKeys: [keyAgreementId],
                    accept: ['didcomm/aip2;env=rfc19'],
                }));
                // If 'DIDComm' included in types, add DIDComm v2 entry
                if (processedTypes.includes('DIDComm')) {
                    builder
                        .addService(new DidCommV2Service_1.DidCommV2Service({
                        id: `${parsed.did}#didcomm-1`,
                        serviceEndpoint: endpoint,
                        routingKeys: routingKeys !== null && routingKeys !== void 0 ? routingKeys : [],
                        accept: ['didcomm/v2'],
                    }))
                        .addContext('https://didcomm.org/messaging/contexts/v2');
                }
            }
        }
        // Add other endpoint types
        for (const [type, endpoint] of Object.entries(otherEndpoints)) {
            builder.addService(new domain_1.DidDocumentService({
                id: `${parsed.did}#${type}`,
                serviceEndpoint: endpoint,
                type,
            }));
        }
    }
}
exports.SovDidResolver = SovDidResolver;
//# sourceMappingURL=SovDidResolver.js.map