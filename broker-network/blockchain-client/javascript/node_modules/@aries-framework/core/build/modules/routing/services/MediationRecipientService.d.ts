import type { AgentMessage } from '../../../agent/AgentMessage';
import type { InboundMessageContext } from '../../../agent/models/InboundMessageContext';
import type { ConnectionRecord } from '../../connections';
import type { Routing } from '../../connections/services/ConnectionService';
import type { KeylistUpdateResponseMessage, MediationDenyMessage, MediationGrantMessage, MessageDeliveryMessage } from '../messages';
import type { StatusMessage } from '../messages/StatusMessage';
import { AgentConfig } from '../../../agent/AgentConfig';
import { EventEmitter } from '../../../agent/EventEmitter';
import { MessageSender } from '../../../agent/MessageSender';
import { Wallet } from '../../../wallet/Wallet';
import { ConnectionService } from '../../connections/services/ConnectionService';
import { StatusRequestMessage, DeliveryRequestMessage, MessagesReceivedMessage, MediationRequestMessage } from '../messages';
import { KeylistUpdateMessage } from '../messages/KeylistUpdateMessage';
import { MediationRecord } from '../repository/MediationRecord';
import { MediationRepository } from '../repository/MediationRepository';
export declare class MediationRecipientService {
    private wallet;
    private mediationRepository;
    private eventEmitter;
    private connectionService;
    private messageSender;
    private config;
    constructor(wallet: Wallet, connectionService: ConnectionService, messageSender: MessageSender, config: AgentConfig, mediatorRepository: MediationRepository, eventEmitter: EventEmitter);
    createStatusRequest(mediationRecord: MediationRecord, config?: {
        recipientKey?: string;
    }): Promise<StatusRequestMessage>;
    createRequest(connection: ConnectionRecord): Promise<MediationProtocolMsgReturnType<MediationRequestMessage>>;
    processMediationGrant(messageContext: InboundMessageContext<MediationGrantMessage>): Promise<MediationRecord>;
    processKeylistUpdateResults(messageContext: InboundMessageContext<KeylistUpdateResponseMessage>): Promise<void>;
    keylistUpdateAndAwait(mediationRecord: MediationRecord, verKey: string, timeoutMs?: number): Promise<MediationRecord>;
    createKeylistUpdateMessage(verkey: string): KeylistUpdateMessage;
    getRouting({ mediatorId, useDefaultMediator }?: GetRoutingOptions): Promise<Routing>;
    processMediationDeny(messageContext: InboundMessageContext<MediationDenyMessage>): Promise<MediationRecord>;
    processStatus(messageContext: InboundMessageContext<StatusMessage>): Promise<DeliveryRequestMessage | null>;
    processDelivery(messageContext: InboundMessageContext<MessageDeliveryMessage>): Promise<MessagesReceivedMessage>;
    /**
     * Update the record to a new state and emit an state changed event. Also updates the record
     * in storage.
     *
     * @param MediationRecord The proof record to update the state for
     * @param newState The state to update to
     *
     */
    private updateState;
    private emitStateChangedEvent;
    getById(id: string): Promise<MediationRecord>;
    findByConnectionId(connectionId: string): Promise<MediationRecord | null>;
    getMediators(): Promise<MediationRecord[]>;
    findDefaultMediator(): Promise<MediationRecord | null>;
    discoverMediation(mediatorId?: string): Promise<MediationRecord | undefined>;
    setDefaultMediator(mediator: MediationRecord): Promise<void>;
    clearDefaultMediator(): Promise<void>;
}
export interface MediationProtocolMsgReturnType<MessageType extends AgentMessage> {
    message: MessageType;
    mediationRecord: MediationRecord;
}
export interface GetRoutingOptions {
    /**
     * Identifier of the mediator to use when setting up routing
     */
    mediatorId?: string;
    /**
     * Whether to use the default mediator if available and `mediatorId` has not been provided
     * @default true
     */
    useDefaultMediator?: boolean;
}
