"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.RecipientModule = void 0;
const rxjs_1 = require("rxjs");
const operators_1 = require("rxjs/operators");
const tsyringe_1 = require("tsyringe");
const AgentConfig_1 = require("../../agent/AgentConfig");
const Dispatcher_1 = require("../../agent/Dispatcher");
const EventEmitter_1 = require("../../agent/EventEmitter");
const MessageReceiver_1 = require("../../agent/MessageReceiver");
const MessageSender_1 = require("../../agent/MessageSender");
const helpers_1 = require("../../agent/helpers");
const error_1 = require("../../error");
const transport_1 = require("../../transport");
const services_1 = require("../connections/services");
const dids_1 = require("../dids");
const discover_features_1 = require("../discover-features");
const MediatorPickupStrategy_1 = require("./MediatorPickupStrategy");
const RoutingEvents_1 = require("./RoutingEvents");
const handlers_1 = require("./handlers");
const KeylistUpdateResponseHandler_1 = require("./handlers/KeylistUpdateResponseHandler");
const MediationDenyHandler_1 = require("./handlers/MediationDenyHandler");
const MediationGrantHandler_1 = require("./handlers/MediationGrantHandler");
const messages_1 = require("./messages");
const BatchPickupMessage_1 = require("./messages/BatchPickupMessage");
const MediationState_1 = require("./models/MediationState");
const repository_1 = require("./repository");
const MediationRecipientService_1 = require("./services/MediationRecipientService");
let RecipientModule = class RecipientModule {
    constructor(dispatcher, agentConfig, mediationRecipientService, connectionService, dids, messageSender, messageReceiver, eventEmitter, discoverFeaturesModule, mediationRepository) {
        this.agentConfig = agentConfig;
        this.connectionService = connectionService;
        this.dids = dids;
        this.mediationRecipientService = mediationRecipientService;
        this.messageSender = messageSender;
        this.messageReceiver = messageReceiver;
        this.eventEmitter = eventEmitter;
        this.logger = agentConfig.logger;
        this.discoverFeaturesModule = discoverFeaturesModule;
        this.mediationRepository = mediationRepository;
        this.registerHandlers(dispatcher);
    }
    async initialize() {
        const { defaultMediatorId, clearDefaultMediator } = this.agentConfig;
        // Set default mediator by id
        if (defaultMediatorId) {
            const mediatorRecord = await this.mediationRecipientService.getById(defaultMediatorId);
            await this.mediationRecipientService.setDefaultMediator(mediatorRecord);
        }
        // Clear the stored default mediator
        else if (clearDefaultMediator) {
            await this.mediationRecipientService.clearDefaultMediator();
        }
        // Poll for messages from mediator
        const defaultMediator = await this.findDefaultMediator();
        if (defaultMediator) {
            await this.initiateMessagePickup(defaultMediator);
        }
    }
    async sendMessage(outboundMessage) {
        const { mediatorPickupStrategy } = this.agentConfig;
        const transportPriority = mediatorPickupStrategy === MediatorPickupStrategy_1.MediatorPickupStrategy.Implicit
            ? { schemes: ['wss', 'ws'], restrictive: true }
            : undefined;
        await this.messageSender.sendMessage(outboundMessage, {
            transportPriority,
            // TODO: add keepAlive: true to enforce through the public api
            // we need to keep the socket alive. It already works this way, but would
            // be good to make more explicit from the public facing API.
            // This would also make it easier to change the internal API later on.
            // keepAlive: true,
        });
    }
    async openMediationWebSocket(mediator) {
        const connection = await this.connectionService.getById(mediator.connectionId);
        const { message, connectionRecord } = await this.connectionService.createTrustPing(connection, {
            responseRequested: false,
        });
        const websocketSchemes = ['ws', 'wss'];
        const didDocument = connectionRecord.theirDid && (await this.dids.resolveDidDocument(connectionRecord.theirDid));
        const services = didDocument && (didDocument === null || didDocument === void 0 ? void 0 : didDocument.didCommServices);
        const hasWebSocketTransport = services && services.some((s) => websocketSchemes.includes(s.protocolScheme));
        if (!hasWebSocketTransport) {
            throw new error_1.AriesFrameworkError('Cannot open websocket to connection without websocket service endpoint');
        }
        await this.messageSender.sendMessage(helpers_1.createOutboundMessage(connectionRecord, message), {
            transportPriority: {
                schemes: websocketSchemes,
                restrictive: true,
                // TODO: add keepAlive: true to enforce through the public api
                // we need to keep the socket alive. It already works this way, but would
                // be good to make more explicit from the public facing API.
                // This would also make it easier to change the internal API later on.
                // keepAlive: true,
            },
        });
    }
    async openWebSocketAndPickUp(mediator, pickupStrategy) {
        let interval = 50;
        // Listens to Outbound websocket closed events and will reopen the websocket connection
        // in a recursive back off strategy if it matches the following criteria:
        // - Agent is not shutdown
        // - Socket was for current mediator connection id
        this.eventEmitter
            .observable(transport_1.TransportEventTypes.OutboundWebSocketClosedEvent)
            .pipe(
        // Stop when the agent shuts down
        operators_1.takeUntil(this.agentConfig.stop$), operators_1.filter((e) => e.payload.connectionId === mediator.connectionId), 
        // Make sure we're not reconnecting multiple times
        operators_1.throttleTime(interval), 
        // Increase the interval (recursive back-off)
        operators_1.tap(() => (interval *= 2)), 
        // Wait for interval time before reconnecting
        operators_1.delayWhen(() => rxjs_1.timer(interval)))
            .subscribe(async () => {
            this.logger.warn(`Websocket connection to mediator with connectionId '${mediator.connectionId}' is closed, attempting to reconnect...`);
            try {
                if (pickupStrategy === MediatorPickupStrategy_1.MediatorPickupStrategy.PickUpV2) {
                    // Start Pickup v2 protocol to receive messages received while websocket offline
                    await this.sendStatusRequest({ mediatorId: mediator.id });
                }
                else {
                    await this.openMediationWebSocket(mediator);
                }
            }
            catch (error) {
                this.logger.warn('Unable to re-open websocket connection to mediator', { error });
            }
        });
        try {
            if (pickupStrategy === MediatorPickupStrategy_1.MediatorPickupStrategy.Implicit) {
                await this.openMediationWebSocket(mediator);
            }
        }
        catch (error) {
            this.logger.warn('Unable to open websocket connection to mediator', { error });
        }
    }
    async initiateMessagePickup(mediator) {
        const { mediatorPollingInterval } = this.agentConfig;
        const mediatorPickupStrategy = await this.getPickupStrategyForMediator(mediator);
        const mediatorConnection = await this.connectionService.getById(mediator.connectionId);
        switch (mediatorPickupStrategy) {
            case MediatorPickupStrategy_1.MediatorPickupStrategy.PickUpV2:
                this.agentConfig.logger.info(`Starting pickup of messages from mediator '${mediator.id}'`);
                await this.openWebSocketAndPickUp(mediator, mediatorPickupStrategy);
                await this.sendStatusRequest({ mediatorId: mediator.id });
                break;
            case MediatorPickupStrategy_1.MediatorPickupStrategy.PickUpV1: {
                // Explicit means polling every X seconds with batch message
                this.agentConfig.logger.info(`Starting explicit (batch) pickup of messages from mediator '${mediator.id}'`);
                const subscription = rxjs_1.interval(mediatorPollingInterval)
                    .pipe(operators_1.takeUntil(this.agentConfig.stop$))
                    .subscribe(async () => {
                    await this.pickupMessages(mediatorConnection);
                });
                return subscription;
            }
            case MediatorPickupStrategy_1.MediatorPickupStrategy.Implicit:
                // Implicit means sending ping once and keeping connection open. This requires a long-lived transport
                // such as WebSockets to work
                this.agentConfig.logger.info(`Starting implicit pickup of messages from mediator '${mediator.id}'`);
                await this.openWebSocketAndPickUp(mediator, mediatorPickupStrategy);
                break;
            default:
                this.agentConfig.logger.info(`Skipping pickup of messages from mediator '${mediator.id}' due to pickup strategy none`);
        }
    }
    async sendStatusRequest(config) {
        const mediationRecord = await this.mediationRecipientService.getById(config.mediatorId);
        const statusRequestMessage = await this.mediationRecipientService.createStatusRequest(mediationRecord, {
            recipientKey: config.recipientKey,
        });
        const mediatorConnection = await this.connectionService.getById(mediationRecord.connectionId);
        return this.messageSender.sendMessage(helpers_1.createOutboundMessage(mediatorConnection, statusRequestMessage));
    }
    async getPickupStrategyForMediator(mediator) {
        var _a;
        let mediatorPickupStrategy = (_a = mediator.pickupStrategy) !== null && _a !== void 0 ? _a : this.agentConfig.mediatorPickupStrategy;
        // If mediator pickup strategy is not configured we try to query if batch pickup
        // is supported through the discover features protocol
        if (!mediatorPickupStrategy) {
            const isPickUpV2Supported = await this.discoverFeaturesModule.isProtocolSupported(mediator.connectionId, messages_1.StatusRequestMessage);
            if (isPickUpV2Supported) {
                mediatorPickupStrategy = MediatorPickupStrategy_1.MediatorPickupStrategy.PickUpV2;
            }
            else {
                const isBatchPickupSupported = await this.discoverFeaturesModule.isProtocolSupported(mediator.connectionId, BatchPickupMessage_1.BatchPickupMessage);
                // Use explicit pickup strategy
                mediatorPickupStrategy = isBatchPickupSupported
                    ? MediatorPickupStrategy_1.MediatorPickupStrategy.PickUpV1
                    : MediatorPickupStrategy_1.MediatorPickupStrategy.Implicit;
            }
            // Store the result so it can be reused next time
            mediator.pickupStrategy = mediatorPickupStrategy;
            await this.mediationRepository.update(mediator);
        }
        return mediatorPickupStrategy;
    }
    async discoverMediation() {
        return this.mediationRecipientService.discoverMediation();
    }
    async pickupMessages(mediatorConnection) {
        mediatorConnection.assertReady();
        const batchPickupMessage = new BatchPickupMessage_1.BatchPickupMessage({ batchSize: 10 });
        const outboundMessage = helpers_1.createOutboundMessage(mediatorConnection, batchPickupMessage);
        await this.sendMessage(outboundMessage);
    }
    async setDefaultMediator(mediatorRecord) {
        return this.mediationRecipientService.setDefaultMediator(mediatorRecord);
    }
    async requestMediation(connection) {
        const { mediationRecord, message } = await this.mediationRecipientService.createRequest(connection);
        const outboundMessage = helpers_1.createOutboundMessage(connection, message);
        await this.sendMessage(outboundMessage);
        return mediationRecord;
    }
    async notifyKeylistUpdate(connection, verkey) {
        const message = this.mediationRecipientService.createKeylistUpdateMessage(verkey);
        const outboundMessage = helpers_1.createOutboundMessage(connection, message);
        await this.sendMessage(outboundMessage);
    }
    async findByConnectionId(connectionId) {
        return await this.mediationRecipientService.findByConnectionId(connectionId);
    }
    async getMediators() {
        return await this.mediationRecipientService.getMediators();
    }
    async findDefaultMediator() {
        return this.mediationRecipientService.findDefaultMediator();
    }
    async findDefaultMediatorConnection() {
        const mediatorRecord = await this.findDefaultMediator();
        if (mediatorRecord) {
            return this.connectionService.getById(mediatorRecord.connectionId);
        }
        return null;
    }
    async requestAndAwaitGrant(connection, timeoutMs = 10000) {
        const { mediationRecord, message } = await this.mediationRecipientService.createRequest(connection);
        // Create observable for event
        const observable = this.eventEmitter.observable(RoutingEvents_1.RoutingEventTypes.MediationStateChanged);
        const subject = new rxjs_1.ReplaySubject(1);
        // Apply required filters to observable stream subscribe to replay subject
        observable
            .pipe(
        // Only take event for current mediation record
        operators_1.filter((event) => event.payload.mediationRecord.id === mediationRecord.id), 
        // Only take event for previous state requested, current state granted
        operators_1.filter((event) => event.payload.previousState === MediationState_1.MediationState.Requested), operators_1.filter((event) => event.payload.mediationRecord.state === MediationState_1.MediationState.Granted), 
        // Only wait for first event that matches the criteria
        operators_1.first(), 
        // Do not wait for longer than specified timeout
        operators_1.timeout(timeoutMs))
            .subscribe(subject);
        // Send mediation request message
        const outboundMessage = helpers_1.createOutboundMessage(connection, message);
        await this.sendMessage(outboundMessage);
        const event = await rxjs_1.firstValueFrom(subject);
        return event.payload.mediationRecord;
    }
    /**
     * Requests mediation for a given connection and sets that as default mediator.
     *
     * @param connection connection record which will be used for mediation
     * @returns mediation record
     */
    async provision(connection) {
        this.logger.debug('Connection completed, requesting mediation');
        let mediation = await this.findByConnectionId(connection.id);
        if (!mediation) {
            this.agentConfig.logger.info(`Requesting mediation for connection ${connection.id}`);
            mediation = await this.requestAndAwaitGrant(connection, 60000); // TODO: put timeout as a config parameter
            this.logger.debug('Mediation granted, setting as default mediator');
            await this.setDefaultMediator(mediation);
            this.logger.debug('Default mediator set');
        }
        else {
            this.agentConfig.logger.warn(`Mediator invitation has already been ${mediation.isReady ? 'granted' : 'requested'}`);
        }
        return mediation;
    }
    async getRouting(options) {
        return this.mediationRecipientService.getRouting(options);
    }
    // Register handlers for the several messages for the mediator.
    registerHandlers(dispatcher) {
        dispatcher.registerHandler(new KeylistUpdateResponseHandler_1.KeylistUpdateResponseHandler(this.mediationRecipientService));
        dispatcher.registerHandler(new MediationGrantHandler_1.MediationGrantHandler(this.mediationRecipientService));
        dispatcher.registerHandler(new MediationDenyHandler_1.MediationDenyHandler(this.mediationRecipientService));
        dispatcher.registerHandler(new handlers_1.StatusHandler(this.mediationRecipientService));
        dispatcher.registerHandler(new handlers_1.MessageDeliveryHandler(this.mediationRecipientService));
        //dispatcher.registerHandler(new KeylistListHandler(this.mediationRecipientService)) // TODO: write this
    }
};
RecipientModule = __decorate([
    tsyringe_1.scoped(tsyringe_1.Lifecycle.ContainerScoped),
    __metadata("design:paramtypes", [Dispatcher_1.Dispatcher,
        AgentConfig_1.AgentConfig,
        MediationRecipientService_1.MediationRecipientService,
        services_1.ConnectionService,
        dids_1.DidsModule,
        MessageSender_1.MessageSender,
        MessageReceiver_1.MessageReceiver,
        EventEmitter_1.EventEmitter,
        discover_features_1.DiscoverFeaturesModule,
        repository_1.MediationRepository])
], RecipientModule);
exports.RecipientModule = RecipientModule;
//# sourceMappingURL=RecipientModule.js.map